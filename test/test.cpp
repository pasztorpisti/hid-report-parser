// The descriptor comments were generated by: https://eleccelerator.com/usbdescreqparser/
// The linked parser seems to have a few bugs. For example:
// - It parses REPORT_COUNT as a signed integer. e.g.: 0xE8 -> -24
// - Sometimes it shows an incorrect decimal value in case of large unsigned
//   16- and 32-bit values, e.g.: 0xFFFF -> 65534

#include "pch.h"

#include "hid_report_parser.h"
#include "descriptor_samples.h"

#include <assert.h>
#include <vector>
#include <set>
#include <map>


using namespace hid;


/*
int main(int argc, char** argv) {
	testing::InitGoogleTest(&argc, argv);
	// InitGoogleTest creates a lot of leaks so we start leak detection after
	// its execution. RUN_ALL_TESTS() also has at least one leak that seems to
	// originate in the google test library. We are probably better off
	// creating MemoryLeakDetector instances on a per-test basis.
	MemoryLeakDetector memory_leak_detector(-1, "main");
	return RUN_ALL_TESTS();
}
*/


// This Report class is used to construct binary HID report messages for testing.
// The starting bit position and bit size of an integer aren't necessarily byte
// aligned within the report.
// The bit and byte order are little endian as per HID specification.
class Report {
public:
	void Int64(uint32_t v) { UInt((uint64_t)v, 64); }
	void Int32(uint32_t v) { UInt((uint64_t)v, 32); }
	void Int16(uint16_t v) { UInt((uint64_t)v, 16); }
	void Int8(uint8_t v)   { UInt((uint64_t)v, 8); }
	void Int(int64_t v, int num_bits=64) { UInt((uint64_t)v, num_bits); }

	void UInt64(uint32_t v) { UInt((uint64_t)v, 64); }
	void UInt32(uint32_t v) { UInt((uint64_t)v, 32); }
	void UInt16(uint16_t v) { UInt((uint64_t)v, 16); }
	void UInt8(uint8_t v)   { UInt((uint64_t)v, 8); }
	// Appends up to 64 bits to the report data with little endian bit and byte order.
	void UInt(uint64_t v, int num_bits=64) {
		assert(num_bits >= 1 && num_bits <= 64);
		for (size_t i=0,e=(size_t)num_bits; i<e; i++)
			Bit(v & ((uint64_t)1 << i));
	}

	// Appends one bit to the report data.
	void Bit(uint64_t bool_value) {
		size_t idx = _pos >> 3;
		size_t shift = _pos & 7;
		if (shift == 0)
			_bytes.resize(idx + 1, 0);
		if (bool_value)
			_bytes[idx] |= 1 << shift;
		_pos++;
	}

	void Clear() {
		_pos = 0;
		_bytes.clear();
	}

	const uint8_t* Bytes() {
		// the report has to be byte aligned
		assert((_pos & 7) == 0);
		return _bytes.data();
	}

	size_t Size() const {
		// the report has to be byte aligned
		assert((_pos & 7) == 0);
		return _bytes.size();
	}

private:
	size_t _pos = 0; // bit position
	std::vector<uint8_t> _bytes;
};


TEST(CommonInputDeviceTypeDetector, Detect) {
	MemoryLeakDetector memory_leak_detector;

	{
		using namespace descriptor_samples::mouse;

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(ZOWIE_FK2, sizeof(ZOWIE_FK2)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(RAZER_VIPER_ULTIMATE_1, sizeof(RAZER_VIPER_ULTIMATE_1)));
		EXPECT_EQ(FLAG_KEYBOARD|FLAG_CONSUMER, detect_common_input_device_type(RAZER_VIPER_ULTIMATE_2, sizeof(RAZER_VIPER_ULTIMATE_2)));
		EXPECT_EQ(FLAG_KEYBOARD, detect_common_input_device_type(RAZER_VIPER_ULTIMATE_3, sizeof(RAZER_VIPER_ULTIMATE_3)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(RAZER_PRO_CLICK_MINI_1, sizeof(RAZER_PRO_CLICK_MINI_1)));
		EXPECT_EQ(FLAG_MOUSE|FLAG_KEYBOARD|FLAG_CONSUMER, detect_common_input_device_type(RAZER_PRO_CLICK_MINI_2, sizeof(RAZER_PRO_CLICK_MINI_2)));
		EXPECT_EQ(FLAG_KEYBOARD, detect_common_input_device_type(RAZER_PRO_CLICK_MINI_3, sizeof(RAZER_PRO_CLICK_MINI_3)));
		EXPECT_EQ(FLAG_CONSUMER, detect_common_input_device_type(RAZER_PRO_CLICK_MINI_4, sizeof(RAZER_PRO_CLICK_MINI_4)));
		EXPECT_EQ(0, detect_common_input_device_type(RAZER_PRO_CLICK_MINI_5, sizeof(RAZER_PRO_CLICK_MINI_5)));

		EXPECT_EQ(FLAG_KEYBOARD, detect_common_input_device_type(LOGITECH_G305_1, sizeof(LOGITECH_G305_1)));
		EXPECT_EQ(FLAG_MOUSE|FLAG_CONSUMER, detect_common_input_device_type(LOGITECH_G305_2, sizeof(LOGITECH_G305_2)));
		EXPECT_EQ(0, detect_common_input_device_type(LOGITECH_G305_3, sizeof(LOGITECH_G305_3)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(LOGITECH_G203_1, sizeof(LOGITECH_G203_1)));
		EXPECT_EQ(FLAG_KEYBOARD|FLAG_CONSUMER, detect_common_input_device_type(LOGITECH_G203_2, sizeof(LOGITECH_G203_2)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(RASPBERRY_PI, sizeof(RASPBERRY_PI)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(GLORIOUS_MODEL_O_MINUS_WIRED_1, sizeof(GLORIOUS_MODEL_O_MINUS_WIRED_1)));
		EXPECT_EQ(FLAG_KEYBOARD|FLAG_CONSUMER, detect_common_input_device_type(GLORIOUS_MODEL_O_MINUS_WIRED_2, sizeof(GLORIOUS_MODEL_O_MINUS_WIRED_2)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(EASTERN_TIMES_TECHNOLOGY_T16_1, sizeof(EASTERN_TIMES_TECHNOLOGY_T16_1)));
		EXPECT_EQ(FLAG_KEYBOARD|FLAG_CONSUMER, detect_common_input_device_type(EASTERN_TIMES_TECHNOLOGY_T16_2, sizeof(EASTERN_TIMES_TECHNOLOGY_T16_2)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(MMG_MARS, sizeof(MMG_MARS)));

		EXPECT_EQ(FLAG_MOUSE|FLAG_KEYBOARD|FLAG_CONSUMER, detect_common_input_device_type(HAVIT, sizeof(HAVIT)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(LUDOS_FLAMMA_1, sizeof(LUDOS_FLAMMA_1)));
		EXPECT_EQ(FLAG_KEYBOARD|FLAG_CONSUMER, detect_common_input_device_type(LUDOS_FLAMMA_2, sizeof(LUDOS_FLAMMA_2)));
		EXPECT_EQ(0, detect_common_input_device_type(LUDOS_FLAMMA_3, sizeof(LUDOS_FLAMMA_3)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(UNKNOWN_1, sizeof(UNKNOWN_1)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(UNKNOWN_2, sizeof(UNKNOWN_2)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(ARDUINO_MOUSE_LIBRARY, sizeof(ARDUINO_MOUSE_LIBRARY)));

		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(HANDCRAFTED_1, sizeof(HANDCRAFTED_1)));
		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(HANDCRAFTED_2, sizeof(HANDCRAFTED_2)));
		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(HANDCRAFTED_3, sizeof(HANDCRAFTED_3)));
		EXPECT_EQ(FLAG_MOUSE, detect_common_input_device_type(HANDCRAFTED_4, sizeof(HANDCRAFTED_4)));
	}

	{
		using namespace descriptor_samples::keyboard;

		EXPECT_EQ(FLAG_KEYBOARD, detect_common_input_device_type(COOLERMASTER_MASTERKEYS_S_1, sizeof(COOLERMASTER_MASTERKEYS_S_1)));
		EXPECT_EQ(0, detect_common_input_device_type(COOLERMASTER_MASTERKEYS_S_2, sizeof(COOLERMASTER_MASTERKEYS_S_2)));
		EXPECT_EQ(FLAG_KEYBOARD|FLAG_CONSUMER, detect_common_input_device_type(COOLERMASTER_MASTERKEYS_S_3, sizeof(COOLERMASTER_MASTERKEYS_S_3)));

		EXPECT_EQ(FLAG_KEYBOARD, detect_common_input_device_type(RASPBERRY_PI_1, sizeof(RASPBERRY_PI_1)));
		EXPECT_EQ(FLAG_CONSUMER, detect_common_input_device_type(RASPBERRY_PI_2, sizeof(RASPBERRY_PI_2)));
	}

	{
		using namespace descriptor_samples::gamepad;

		EXPECT_EQ(FLAG_GAMEPAD, detect_common_input_device_type(PS4_1, sizeof(PS4_1)));

		EXPECT_EQ(FLAG_GAMEPAD, detect_common_input_device_type(PS4_2, sizeof(PS4_2)));

		EXPECT_EQ(FLAG_JOYSTICK, detect_common_input_device_type(X52_PRO_HOTAS, sizeof(X52_PRO_HOTAS)));

		EXPECT_EQ(FLAG_JOYSTICK, detect_common_input_device_type(X52_HOTAS, sizeof(X52_HOTAS)));

		EXPECT_EQ(FLAG_JOYSTICK, detect_common_input_device_type(SPEEDLINK_PHANTOM_HAWK, sizeof(SPEEDLINK_PHANTOM_HAWK)));
	}
}


void field_usage_set(const UsageExtractor::Collection& c, std::set<uint32_t>& field_usages) {
	for (auto const& ur : c.field_usages[uint8_t(ReportType::input)]) {
		uint32_t page32 = (uint32_t)ur.usage_page << 16;
		for (uint32_t u=ur.usage_min; u<=ur.usage_max; u++)
			field_usages.insert(page32 | u);
	}
}


uint32_t make_usage32(uint16_t usage_page, uint16_t usage) {
	return ((uint32_t)usage_page << 16) | usage;
}


TEST(UsageExtractor, SingleApplicationCollection) {
	MemoryLeakDetector memory_leak_detector;

	using descriptor_samples::mouse::ZOWIE_FK2;

	UsageExtractor e;
	UsageExtractor::Report r;
	int res = e.ScanDescriptor(ZOWIE_FK2, sizeof(ZOWIE_FK2), r);
	ASSERT_EQ(res, 0);
	ASSERT_EQ(r.collections.size(), 1);

	EXPECT_EQ(r.collections[0].type, COLLECTION_TYPE_APPLICATION);
	EXPECT_EQ(r.collections[0].usage_page, PAGE_GENERIC_DESKTOP);
	EXPECT_EQ(r.collections[0].usage, USAGE_MOUSE);

	std::set<uint32_t> usages;
	field_usage_set(r.collections[0], usages);
	EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 1)) != usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 2)) != usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 3)) != usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 4)) != usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 5)) != usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 6)) != usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 7)) == usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_X)) != usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_Y)) != usages.end());
	EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_WHEEL)) != usages.end());
}


TEST(UsageExtractor, MultipleApplicationCollections) {
	MemoryLeakDetector memory_leak_detector;

	using descriptor_samples::mouse::RAZER_PRO_CLICK_MINI_2;

	UsageExtractor e;
	UsageExtractor::Report r;
	int res = e.ScanDescriptor(RAZER_PRO_CLICK_MINI_2, sizeof(RAZER_PRO_CLICK_MINI_2), r);
	ASSERT_EQ(res, 0);
	ASSERT_EQ(r.collections.size(), 8);

	std::map<uint32_t, size_t> c_usages;
	for (size_t i=0,e=r.collections.size(); i<e; i++)
		c_usages[make_usage32(r.collections[i].usage_page, r.collections[i].usage)] = i;

	ASSERT_TRUE(c_usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_KEYBOARD)) != c_usages.end());
	ASSERT_TRUE(c_usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_MOUSE)) != c_usages.end());
	ASSERT_TRUE(c_usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_SYSTEM_CONTROL)) != c_usages.end());
	ASSERT_TRUE(c_usages.find(make_usage32(PAGE_CONSUMER, USAGE_CONSUMER_CONTROL)) != c_usages.end());

	{
		std::set<uint32_t> usages;
		field_usage_set(r.collections[c_usages[make_usage32(PAGE_GENERIC_DESKTOP, USAGE_KEYBOARD)]], usages);
		EXPECT_EQ(usages.size(), 0x100);
		for (uint16_t u=0; u<=0xff; u++)
			ASSERT_TRUE(usages.find(make_usage32(PAGE_KEYBOARD, u)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_KEYBOARD, 0x100)) == usages.end());
	}

	{
		std::set<uint32_t> usages;
		field_usage_set(r.collections[c_usages[make_usage32(PAGE_GENERIC_DESKTOP, USAGE_MOUSE)]], usages);
		EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 1)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 2)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 3)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 4)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 5)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 6)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_BUTTON, 7)) == usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_X)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_Y)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_WHEEL)) != usages.end());
	}

	{
		std::set<uint32_t> usages;
		field_usage_set(r.collections[c_usages[make_usage32(PAGE_GENERIC_DESKTOP, USAGE_SYSTEM_CONTROL)]], usages);
		EXPECT_EQ(usages.size(), 3);
		EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_SYSTEM_POWER_DOWN)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_SYSTEM_SLEEP)) != usages.end());
		EXPECT_TRUE(usages.find(make_usage32(PAGE_GENERIC_DESKTOP, USAGE_SYSTEM_WAKEUP)) != usages.end());
	}

	{
		std::set<uint32_t> usages;
		field_usage_set(r.collections[c_usages[make_usage32(PAGE_CONSUMER, USAGE_CONSUMER_CONTROL)]], usages);
		EXPECT_EQ(usages.size(), 0x23d);
		for (uint16_t u=0; u<=0x23c; u++)
			ASSERT_TRUE(usages.find(make_usage32(PAGE_CONSUMER, u)) != usages.end());
	}
}


TEST(DescriptorParser, IgnoredSkippedItems) {
	MemoryLeakDetector memory_leak_detector;

	// Items that should be ignored by the descriptor parser:
	// - DESIGNATOR INDEX/MIN/MAX
	// - STRING INDEX/MIN/MAX
	// - DELIMITER
	static const uint8_t DESC[] = {
		0xFE, 0x0B, 0x88,  // Long Item (0x88)          <- must be ignored
		0x57, 0x4F, 0x4F, 0x46, 0x21, 0x20, 0x57, 0x4F, 0x4F, 0x46, 0x21,  //   Long Item Data (11 bytes)  <- must be ignored

		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        // Usage (X)

		0x39, 0x05,        // Designator Index (5)      <- must be ignored
		0x49, 0x06,        // Designator Minimum (6)    <- must be ignored
		0x5A, 0x10, 0x01,  // Designator Maximum (272)  <- must be ignored
		0x79, 0x08,        // String Index (8)          <- must be ignored
		0x89, 0x09,        // String Minimum (9)        <- must be ignored
		0x9A, 0x04, 0x01,  // String Maximum (260)      <- must be ignored
		0xA9, 0x02,        // Delimiter (2)             <- must be ignored

		0x09, 0x31,        // Usage (Y)

		0xA9, 0x01,        // Delimiter (1)             <- must be ignored
		0xA8,              // Delimiter (0)             <- must be ignored

		0x14,              // Logical Minimum (0)
		0x25, 0x7F,        // Logical Maximum (127)
		0x75, 0x08,        // Report Size (8)
		0x95, 0x02,        // Report Count (2)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
	};

	struct Config {
		Int32Fields axes {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
			},
		};
		Collection c {
			.int32s { &axes },
		};
	};

	Int32Vector axes;
	Config cfg;
	cfg.axes.target = &axes;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.axes.mapped[0]);
	EXPECT_TRUE(cfg.axes.mapped[1]);

	Report r;

	r.Int8(2); // X
	r.Int8(3); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(axes[0], 2);
	EXPECT_EQ(axes[1], 3);

	r.Clear();

	r.Int8(4); // X
	r.Int8(5); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(axes[0], 4);
	EXPECT_EQ(axes[1], 5);
}


TEST(DescriptorParser, ExtendedUsage) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        // Usage (X)
		0x0B, 0x02, 0x00, 0x09, 0x00,  // Extended Usage (Button #2, Button Page)
		0x09, 0x31,        // Usage (Y)
		0x14,              // Logical Minimum (0)
		0x25, 0x7F,        // Logical Maximum (127)
		0x75, 0x08,        // Report Size (8)
		0x95, 0x03,        // Report Count (3)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
	};

	struct Config {
		Int32Fields axes {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
			},
		};
		BoolFields buttons {
			.usages { {PAGE_BUTTON, 2} },
		};
		Collection c {
			.int32s { &axes },
			.bools { &buttons },
		};
	};

	Int32Vector axes;
	BoolVector buttons;
	Config cfg;
	cfg.axes.target = &axes;
	cfg.buttons.target = &buttons;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.axes.mapped[0]);
	EXPECT_TRUE(cfg.axes.mapped[1]);
	EXPECT_TRUE(cfg.buttons.mapped[0]);

	Report r;

	r.Int8(2); // X
	r.Int8(0); // button
	r.Int8(3); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(axes[0], 2);
	EXPECT_EQ(axes[1], 3);
	EXPECT_FALSE(buttons[0]);

	r.Clear();

	r.Int8(4); // X
	r.Int8(1); // button
	r.Int8(5); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(axes[0], 4);
	EXPECT_EQ(axes[1], 5);
	EXPECT_TRUE(buttons[0]);
}


TEST(DescriptorParser, ExtendedUsageMinMax) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        // Usage (X)
		0x1B, 0x02, 0x00, 0x09, 0x00,  // Extended Usage Minimum (Button #2, Button Page)
		0x2B, 0x04, 0x00, 0x09, 0x00,  // Extended Usage Maximum (Button #4, Button Page)
		0x09, 0x31,        // Usage (Y)
		0x14,              // Logical Minimum
		0x25, 0x7F,        // Logical Maximum (127)
		0x75, 0x08,        // Report Size (8)
		0x95, 0x05,        // Report Count (5)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
	};

	struct Config {
		Int32Fields axes {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
			},
		};
		BoolFields buttons {
			.usages { {PAGE_BUTTON, 2, 4} },
		};
		Collection c {
			.int32s { &axes },
			.bools { &buttons },
		};
	};

	Int32Vector axes;
	BoolVector buttons;
	Config cfg;
	cfg.axes.target = &axes;
	cfg.buttons.target = &buttons;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.axes.mapped[0]);
	EXPECT_TRUE(cfg.axes.mapped[1]);
	EXPECT_TRUE(cfg.buttons.mapped[0]);
	EXPECT_TRUE(cfg.buttons.mapped[1]);
	EXPECT_TRUE(cfg.buttons.mapped[2]);

	Report r;

	r.Int8(2); // X
	r.Int8(1); // button #2
	r.Int8(0); // button #3
	r.Int8(0); // button #4
	r.Int8(3); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(axes[0], 2);
	EXPECT_EQ(axes[1], 3);
	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b001);

	r.Clear();

	r.Int8(4); // X
	r.Int8(0); // button #2
	r.Int8(1); // button #3
	r.Int8(0); // button #4
	r.Int8(5); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(axes[0], 4);
	EXPECT_EQ(axes[1], 5);
	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b010);

	r.Clear();

	r.Int8(6); // X
	r.Int8(0); // button #2
	r.Int8(0); // button #3
	r.Int8(1); // button #4
	r.Int8(7); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(axes[0], 6);
	EXPECT_EQ(axes[1], 7);
	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b100);
}


TEST(DescriptorParser, ExtendedUsageMinMax_PageMismatch) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x1B, 0x02, 0x00, 0x09, 0x00,  // Extended Usage Minimum (Button #2, Button Page)
		0x2B, 0x04, 0x00, 0x07, 0x00,  // Extended Usage Maximum (Key A,     Keyboard Page)
	};

	struct Config {
		BoolFields buttons {
			.usages { {PAGE_BUTTON, 2, 4} },
		};
		Collection c {
			.bools { &buttons },
		};
	};

	BoolVector buttons;
	Config cfg;
	cfg.buttons.target = &buttons;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, ERR_EXTENDED_USAGE_MIN_MAX_PAGE_MISMATCH);
}


TEST(SelectiveInputReportParser, FieldMappingPriority_1) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0xA1, 0x01,        // Collection (Application)
		0x05, 0x01,        //   Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        //   Usage (X)
		0x15, 0x81,        //   Logical Minimum (-127)
		0x25, 0x7F,        //   Logical Maximum (127)
		0x95, 0x08,        //   Report Count (8)
		0x75, 0x08,        //   Report Size (8)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
	};

	// The above descriptor has eight Usage(X) fields and the order in which the
	// variables of the below config are mapped onto those eight fields matters:
	// - The variables of the deepest matching config collection must take priority.
	// - Within a config collection the int32 variables are matched before bool variables.

	// In this example all config Collections match the only collection that
	// is declared in the descriptor.

	struct Config {
		Int32Fields c5_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c5_x_2 {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c4_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		BoolFields c4_x_2 {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		BoolFields c4_x_3 {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c3_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c2_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c1_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};

		Collection c5 {
			.type = COLLECTION_TYPE_APPLICATION,
			.int32s { &c5_x, &c5_x_2 },
		};
		Collection c4 {
			.collections { &c5 },
			.int32s { &c4_x },
			.bools { &c4_x_2, &c4_x_3 },
		};
		Collection c3 {
			.type = COLLECTION_TYPE_APPLICATION,
			.collections { &c4 },
			.int32s { &c3_x },
		};
		Collection c2 {
			.collections { &c3 },
			.int32s { &c2_x },
		};
		Collection c1 {
			.collections { &c2 },
			.int32s { &c1_x },
		};
	};

	Int32Vector i1, i2, i3, i4, i5, i5_2;
	BoolVector b4_2, b4_3;
	Config cfg;
	cfg.c1_x.target = &i1;
	cfg.c2_x.target = &i2;
	cfg.c3_x.target = &i3;
	cfg.c4_x.target = &i4;
	cfg.c4_x_2.target = &b4_2;
	cfg.c4_x_3.target = &b4_3;
	cfg.c5_x.target = &i5;
	cfg.c5_x_2.target = &i5_2;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c1, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.c1_x.mapped[0]);
	EXPECT_TRUE(cfg.c2_x.mapped[0]);
	EXPECT_TRUE(cfg.c3_x.mapped[0]);
	EXPECT_TRUE(cfg.c4_x.mapped[0]);
	EXPECT_TRUE(cfg.c4_x_2.mapped[0]);
	EXPECT_TRUE(cfg.c4_x_3.mapped[0]);
	EXPECT_TRUE(cfg.c5_x.mapped[0]);
	EXPECT_TRUE(cfg.c5_x_2.mapped[0]);

	int8_t report[8] = { 5, 52, 4, 0, 43, 3, 2, 1 };
	res = parser.Parse(report, sizeof(report));
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i5[0], 5);
	EXPECT_EQ(i5_2[0], 52);
	EXPECT_EQ(i4[0], 4);
	EXPECT_EQ(b4_2[0], false);	// 0 -> false
	EXPECT_EQ(b4_3[0], true);	// 43 -> true
	EXPECT_EQ(i3[0], 3);
	EXPECT_EQ(i2[0], 2);
	EXPECT_EQ(i1[0], 1);
}


TEST(SelectiveInputReportParser, FieldMappingPriority_2) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x95, 0x01,        // Report Count (1)
		0x75, 0x08,        // Report Size (8)
		0x15, 0x81,        // Logical Minimum (-127)
		0x25, 0x7F,        // Logical Maximum (127)
		0xA1, 0x01,        // Collection (Application)
		0x09, 0x30,        //   Usage (X)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
		0x09, 0x30,        // Usage (X)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xA1, 0x01,        // Collection (Application)
		0x09, 0x30,        //   Usage (X)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
	};

	// The descriptor declares 3 Usage(X) fields. The second one is a top level
	// field (it isn't inside a descriptor collection) so it can be captured
	// only by the root collection of the config.

	struct Config {
		Int32Fields c2_x {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
			},
		};
		Int32Fields c1_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};

		Collection c2 {
			.type = COLLECTION_TYPE_APPLICATION,
			.int32s { &c2_x },
		};
		Collection c1 {
			.collections { &c2 },
			.int32s { &c1_x },
		};
	};

	Int32Vector i1, i2;
	Config cfg;
	cfg.c1_x.target = &i1;
	cfg.c2_x.target = &i2;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c1, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.c1_x.mapped[0]);
	EXPECT_TRUE(cfg.c2_x.mapped[0]);
	EXPECT_TRUE(cfg.c2_x.mapped[1]);

	int8_t report[3] = { 1, 2, 3 };
	res = parser.Parse(report, sizeof(report));
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i1[0], 2);
	EXPECT_EQ(i2[0], 1);
	EXPECT_EQ(i2[1], 3);
}


TEST(SelectiveInputReportParser, FieldMappingPriority_3) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x95, 0x01,        // Report Count (1)
		0x75, 0x08,        // Report Size (8)
		0x15, 0x81,        // Logical Minimum (-127)
		0x25, 0x7F,        // Logical Maximum (127)
		0x09, 0x02,        // Usage (Mouse)
		0xA1, 0x01,        // Collection (Application)
		0x09, 0x30,        //   Usage (X)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
		0xA1, 0x01,        // Collection (Application)
		0x09, 0x30,        //   Usage (X)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
		0x09, 0x30,        // Usage (X)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0x09, 0x06,        // Usage (Keyboard)
		0xA1, 0x01,        // Collection (Application)
		0x09, 0x30,        //   Usage (X)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
	};

	// The descriptor declares 3 Usage(X) fields. The third one isn't inside an
	// application collection so it can be captured only by the root collection
	// of the config.

	struct Config {
		Int32Fields c4_x {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
			},
		};
		Int32Fields c3_x {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
			},
		};
		Int32Fields c2_x {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
			},
		};
		Int32Fields c1_x {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
			},
		};

		Collection c4 {
			.type = COLLECTION_TYPE_APPLICATION,
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_MOUSE },
			},
			.int32s { &c4_x },
		};
		Collection c3 {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_KEYBOARD },
			},
			.int32s { &c3_x },
		};
		Collection c2 {
			.type = COLLECTION_TYPE_APPLICATION,
			.collections { &c3, &c4 },
			.int32s { &c2_x },
		};
		Collection c1 {
			.collections { &c2 },
			.int32s { &c1_x },
		};
	};

	Int32Vector i1, i2, i3, i4;
	Config cfg;
	cfg.c1_x.target = &i1;
	cfg.c2_x.target = &i2;
	cfg.c3_x.target = &i3;
	cfg.c4_x.target = &i4;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c1, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.c1_x.mapped[0]);
	EXPECT_TRUE(cfg.c2_x.mapped[0]);
	EXPECT_TRUE(cfg.c3_x.mapped[0]);
	EXPECT_TRUE(cfg.c4_x.mapped[0]);
	EXPECT_FALSE(cfg.c1_x.mapped[1]);
	EXPECT_FALSE(cfg.c2_x.mapped[1]);
	EXPECT_FALSE(cfg.c3_x.mapped[1]);
	EXPECT_FALSE(cfg.c4_x.mapped[1]);

	int8_t report[4] = { 1, 2, 3, 4 };
	res = parser.Parse(report, sizeof(report));
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i1[0], 3);
	EXPECT_EQ(i2[0], 2);
	EXPECT_EQ(i3[0], 4);
	EXPECT_EQ(i4[0], 1);
}


TEST(SelectiveInputReportParser, FieldMappingPriority_4) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0xA1, 0x02,        // Collection (Logical)
		0x05, 0x01,        //   Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        //   Usage (X)
		0x15, 0x81,        //   Logical Minimum (-127)
		0x25, 0x7F,        //   Logical Maximum (127)
		0x95, 0x03,        //   Report Count (3)
		0x75, 0x08,        //   Report Size (8)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
	};

	// Only the c1 and c6 collections should be able to capture the fields of
	// this descriptor because the other children of c1 (c2 and c4) have filters
	// that aren't satisfied by the logical collection in the descriptor:
	// c2 wants an application collection while c4 wants a collection tagged
	// with USAGE_MOUSE.
	// The c3 and c5 collections are automatically excluded because they are
	// children of collections that can't be mapped onto the descriptor.

	struct Config {
		Int32Fields c6_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c5_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c4_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c3_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c2_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c1_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};

		Collection c6 {
			.int32s { &c6_x },
		};

		Collection c5 {
			.int32s { &c5_x },
		};
		Collection c4 {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_MOUSE} },
			.collections { &c5 },
			.int32s { &c4_x },
		};

		Collection c3 {
			.int32s { &c3_x },
		};
		Collection c2 {
			.type = COLLECTION_TYPE_APPLICATION,
			.collections { &c3 },
			.int32s { &c2_x },
		};
		Collection c1 {
			.collections { &c2, &c4, &c6 },
			.int32s { &c1_x },
		};
	};

	Int32Vector i1, i2, i3, i4, i5, i6;
	Config cfg;
	cfg.c1_x.target = &i1;
	cfg.c2_x.target = &i2;
	cfg.c3_x.target = &i3;
	cfg.c4_x.target = &i4;
	cfg.c5_x.target = &i5;
	cfg.c6_x.target = &i6;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c1, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.c1_x.mapped[0]);
	EXPECT_FALSE(cfg.c2_x.mapped[0]);
	EXPECT_FALSE(cfg.c3_x.mapped[0]);
	EXPECT_FALSE(cfg.c4_x.mapped[0]);
	EXPECT_FALSE(cfg.c5_x.mapped[0]);
	EXPECT_TRUE(cfg.c6_x.mapped[0]);

	int8_t report[3] = { 1, 2, 3 };
	res = parser.Parse(report, sizeof(report));
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i1[0], 2);
	EXPECT_EQ(i2[0], 0);
	EXPECT_EQ(i3[0], 0);
	EXPECT_EQ(i4[0], 0);
	EXPECT_EQ(i5[0], 0);
	EXPECT_EQ(i6[0], 1);
}


TEST(SelectiveInputReportParser, FieldMappingPriority_5) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        // Usage (X)
		0x15, 0x81,        // Logical Minimum (-127)
		0x25, 0x7F,        // Logical Maximum (127)
		0x95, 0x03,        // Report Count (3)
		0x75, 0x08,        // Report Size (8)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
	};

	// The descriptor contains top level fields (they aren't inside collections).
	// This is a special case that doesn't follow the HID specification. This
	// library can map top level descriptor fields only to the root collection
	// of the config and and only if that root doesn't have collection type or
	// usage filters.

	struct Config {
		Int32Fields c6_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c5_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c4_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c3_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c2_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};
		Int32Fields c1_x {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_X} },
		};

		Collection c6 {
			.int32s { &c6_x },
		};

		Collection c5 {
			.int32s { &c5_x },
		};
		Collection c4 {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_MOUSE} },
			.collections { &c5 },
			.int32s { &c4_x },
		};

		Collection c3 {
			.int32s { &c3_x },
		};
		Collection c2 {
			.type = COLLECTION_TYPE_APPLICATION,
			.collections { &c3 },
			.int32s { &c2_x },
		};

		// root without filters
		Collection root_1 {
			.collections { &c2, &c4, &c6 },
			.int32s { &c1_x },
		};

		// root with collection type filter
		Collection root_2 {
			.type = COLLECTION_TYPE_APPLICATION,
			.collections { &c2, &c4, &c6 },
			.int32s { &c1_x },
		};

		// root with collection usage filter
		Collection root_3 {
			.usages { {PAGE_GENERIC_DESKTOP, USAGE_MOUSE} },
			.collections { &c2, &c4, &c6 },
			.int32s { &c1_x },
		};
	};

	// root_1: no filters
	{
		Int32Vector i1, i2, i3, i4, i5, i6;
		Config cfg;
		cfg.c1_x.target = &i1;
		cfg.c2_x.target = &i2;
		cfg.c3_x.target = &i3;
		cfg.c4_x.target = &i4;
		cfg.c5_x.target = &i5;
		cfg.c6_x.target = &i6;

		SelectiveInputReportParser parser;
		int res = parser.Init(&cfg.root_1, DESC, sizeof(DESC));
		EXPECT_EQ(res, 0);

		EXPECT_TRUE(cfg.c1_x.mapped[0]);
		EXPECT_FALSE(cfg.c2_x.mapped[0]);
		EXPECT_FALSE(cfg.c3_x.mapped[0]);
		EXPECT_FALSE(cfg.c4_x.mapped[0]);
		EXPECT_FALSE(cfg.c5_x.mapped[0]);
		EXPECT_FALSE(cfg.c6_x.mapped[0]);

		int8_t report[3] = { 1, 2, 3 };
		res = parser.Parse(report, sizeof(report));
		EXPECT_EQ(res, 0);

		EXPECT_EQ(i1[0], 1);
		EXPECT_EQ(i2[0], 0);
		EXPECT_EQ(i3[0], 0);
		EXPECT_EQ(i4[0], 0);
		EXPECT_EQ(i5[0], 0);
	}

	// root_2: collection type filter
	{
		Int32Vector i1, i2, i3, i4, i5, i6;
		Config cfg;
		cfg.c1_x.target = &i1;
		cfg.c2_x.target = &i2;
		cfg.c3_x.target = &i3;
		cfg.c4_x.target = &i4;
		cfg.c5_x.target = &i5;
		cfg.c6_x.target = &i6;

		SelectiveInputReportParser parser;
		int res = parser.Init(&cfg.root_2, DESC, sizeof(DESC));
		EXPECT_EQ(res, ERR_COULD_NOT_MAP_ANY_USAGES);
	}

	// root_3: collection usage filter
	{
		Int32Vector i1, i2, i3, i4, i5, i6;
		Config cfg;
		cfg.c1_x.target = &i1;
		cfg.c2_x.target = &i2;
		cfg.c3_x.target = &i3;
		cfg.c4_x.target = &i4;
		cfg.c5_x.target = &i5;
		cfg.c6_x.target = &i6;

		SelectiveInputReportParser parser;
		int res = parser.Init(&cfg.root_3, DESC, sizeof(DESC));
		EXPECT_EQ(res, ERR_COULD_NOT_MAP_ANY_USAGES);
	}
}


TEST(SelectiveInputReportParser, ByteAligned_VarFields) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        // Usage (X)
		0x15, 0x81,        // Logical Minimum (-127)
		0x25, 0x7F,        // Logical Maximum (127)
		0x95, 0x02,        // Report Count (2)
		0x75, 0x08,        // Report Size (8)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0x09, 0x31,        // Usage (Y)
		0x16, 0x01, 0x80,  // Logical Minimum (-32767)
		0x26, 0xFF, 0x7F,  // Logical Maximum (32767)
		0x75, 0x10,        // Report Size (16)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0x09, 0x32,        // Usage (Z)
		0x17, 0x01, 0x00, 0x00, 0x80,  // Logical Minimum (-2147483648)
		0x27, 0xFF, 0xFF, 0xFF, 0x7F,  // Logical Maximum (2147483646)
		0x75, 0x20,        // Report Size (32)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
	};

	struct Config {
		Int32Fields f {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
			},
		};
		Collection c {
			.int32s { &f },
		};
	};

	Int32Vector i;
	Config cfg;
	cfg.f.target = &i;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.f.mapped[0]);
	EXPECT_TRUE(cfg.f.mapped[1]);
	EXPECT_TRUE(cfg.f.mapped[2]);
	EXPECT_TRUE(cfg.f.mapped[3]);
	EXPECT_TRUE(cfg.f.mapped[4]);
	EXPECT_TRUE(cfg.f.mapped[5]);

	Report r;
	r.UInt8(2);
	r.Int8(-2);
	r.Int16(3);
	r.Int16(-3);
	r.Int32(4);
	r.Int32(-4);

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i[0], 2);
	EXPECT_EQ(i[1], -2);
	EXPECT_EQ(i[2], 3);
	EXPECT_EQ(i[3], -3);
	EXPECT_EQ(i[4], 4);
	EXPECT_EQ(i[5], -4);

	// If a value in the report is outside of the range of the field's logical
	// min/max then the value of that field has to stay the last reported value
	// (at least in case of absolute fields) as per HID specification.

	r.Clear();

	r.Int8((int8_t)0x80); // out of range
	r.Int8(-5);
	r.Int16((int16_t)0x8000); // out of range
	r.Int16(-6);
	r.Int32((int32_t)0x80000000); // out of range
	r.Int32(-7);

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i[0], 2); // unchanged
	EXPECT_EQ(i[1], -5);
	EXPECT_EQ(i[2], 3); // unchanged
	EXPECT_EQ(i[3], -6);
	EXPECT_EQ(i[4], 4); // unchanged
	EXPECT_EQ(i[5], -7);
}


TEST(SelectiveInputReportParser, Not_ByteAligned_VarFields) {
	MemoryLeakDetector memory_leak_detector;

	// Usage(X): eight 7-bit integers
	// Usage(Y): eight 15-bit integers
	// Usage(Z): eight 31-bit integers
	// This tricky setup makes sure that we have integers of unaligned sizes
	// starting at all 8 possible bit positions within the bytes of the report data.
	static const uint8_t DESC[] = {
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        // Usage (X)
		0x15, 0xC1,        // Logical Minimum (-63)
		0x25, 0x3F,        // Logical Maximum (63)
		0x95, 0x08,        // Report Count (8)
		0x75, 0x07,        // Report Size (7)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0x09, 0x31,        // Usage (Y)
		0x16, 0x01, 0xC0,  // Logical Minimum (-16383)
		0x26, 0xFF, 0x3F,  // Logical Maximum (16383)
		0x75, 0x0F,        // Report Size (15)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0x09, 0x32,        // Usage (Z)
		0x17, 0x01, 0x00, 0x00, 0xC0,  // Logical Minimum (-1073741823)
		0x27, 0xFF, 0xFF, 0xFF, 0x3F,  // Logical Maximum (1073741823)
		0x75, 0x1F,        // Report Size (31)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
	};

	struct Config {
		Int32Fields f {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
			},
		};
		Collection c {
			.int32s { &f },
		};
	};

	Int32Vector i;
	Config cfg;
	cfg.f.target = &i;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.f.mapped[0]);
	EXPECT_TRUE(cfg.f.mapped[1]);
	EXPECT_TRUE(cfg.f.mapped[2]);
	EXPECT_TRUE(cfg.f.mapped[3]);
	EXPECT_TRUE(cfg.f.mapped[4]);
	EXPECT_TRUE(cfg.f.mapped[5]);
	EXPECT_TRUE(cfg.f.mapped[6]);
	EXPECT_TRUE(cfg.f.mapped[7]);
	EXPECT_TRUE(cfg.f.mapped[8]);
	EXPECT_TRUE(cfg.f.mapped[9]);
	EXPECT_TRUE(cfg.f.mapped[10]);
	EXPECT_TRUE(cfg.f.mapped[11]);
	EXPECT_TRUE(cfg.f.mapped[12]);
	EXPECT_TRUE(cfg.f.mapped[13]);
	EXPECT_TRUE(cfg.f.mapped[14]);
	EXPECT_TRUE(cfg.f.mapped[15]);
	EXPECT_TRUE(cfg.f.mapped[16]);
	EXPECT_TRUE(cfg.f.mapped[17]);
	EXPECT_TRUE(cfg.f.mapped[18]);
	EXPECT_TRUE(cfg.f.mapped[19]);
	EXPECT_TRUE(cfg.f.mapped[20]);
	EXPECT_TRUE(cfg.f.mapped[21]);
	EXPECT_TRUE(cfg.f.mapped[22]);
	EXPECT_TRUE(cfg.f.mapped[23]);

	Report r;

	r.Int(4, 7);
	r.Int(3, 7);
	r.Int(2, 7);
	r.Int(1, 7);
	r.Int(-1, 7);
	r.Int(-2, 7);
	r.Int(-3, 7);
	r.Int(-4, 7);

	r.Int(14, 15);
	r.Int(13, 15);
	r.Int(12, 15);
	r.Int(11, 15);
	r.Int(-11, 15);
	r.Int(-12, 15);
	r.Int(-13, 15);
	r.Int(-14, 15);

	r.Int(24, 31);
	r.Int(23, 31);
	r.Int(22, 31);
	r.Int(21, 31);
	r.Int(-21, 31);
	r.Int(-22, 31);
	r.Int(-23, 31);
	r.Int(-24, 31);

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i[0], 4);
	EXPECT_EQ(i[1], 3);
	EXPECT_EQ(i[2], 2);
	EXPECT_EQ(i[3], 1);
	EXPECT_EQ(i[4], -1);
	EXPECT_EQ(i[5], -2);
	EXPECT_EQ(i[6], -3);
	EXPECT_EQ(i[7], -4);

	EXPECT_EQ(i[8], 14);
	EXPECT_EQ(i[9], 13);
	EXPECT_EQ(i[10], 12);
	EXPECT_EQ(i[11], 11);
	EXPECT_EQ(i[12], -11);
	EXPECT_EQ(i[13], -12);
	EXPECT_EQ(i[14], -13);
	EXPECT_EQ(i[15], -14);

	EXPECT_EQ(i[16], 24);
	EXPECT_EQ(i[17], 23);
	EXPECT_EQ(i[18], 22);
	EXPECT_EQ(i[19], 21);
	EXPECT_EQ(i[20], -21);
	EXPECT_EQ(i[21], -22);
	EXPECT_EQ(i[22], -23);
	EXPECT_EQ(i[23], -24);

	// If a value in the report is outside of the range of the field's logical
	// min/max then the value of that field has to stay the last reported value
	// (at least in case of absolute fields) as per HID specification.

	r.Clear();

	r.Int(-64, 7); // out of range
	r.Int(-64, 7); // out of range
	r.Int(-64, 7); // out of range
	r.Int(63, 7);
	r.Int(-63, 7);
	r.Int(-64, 7); // out of range
	r.Int(-64, 7); // out of range
	r.Int(-64, 7); // out of range

	r.Int(-16384, 15); // out of range
	r.Int(-16384, 15); // out of range
	r.Int(-16384, 15); // out of range
	r.Int(16383, 15);
	r.Int(-16383, 15);
	r.Int(-16384, 15); // out of range
	r.Int(-16384, 15); // out of range
	r.Int(-16384, 15); // out of range

	r.Int(-1073741824, 31); // out of range
	r.Int(-1073741824, 31); // out of range
	r.Int(-1073741824, 31); // out of range
	r.Int(1073741823, 31);
	r.Int(-1073741823, 31);
	r.Int(-1073741824, 31); // out of range
	r.Int(-1073741824, 31); // out of range
	r.Int(-1073741824, 31); // out of range

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i[0], 4); // unchanged
	EXPECT_EQ(i[1], 3); // unchanged
	EXPECT_EQ(i[2], 2); // unchanged
	EXPECT_EQ(i[3], 63);
	EXPECT_EQ(i[4], -63);
	EXPECT_EQ(i[5], -2); // unchanged
	EXPECT_EQ(i[6], -3); // unchanged
	EXPECT_EQ(i[7], -4); // unchanged

	EXPECT_EQ(i[8], 14); // unchanged
	EXPECT_EQ(i[9], 13); // unchanged
	EXPECT_EQ(i[10], 12); // unchanged
	EXPECT_EQ(i[11], 16383);
	EXPECT_EQ(i[12], -16383);
	EXPECT_EQ(i[13], -12); // unchanged
	EXPECT_EQ(i[14], -13); // unchanged
	EXPECT_EQ(i[15], -14); // unchanged

	EXPECT_EQ(i[16], 24); // unchanged
	EXPECT_EQ(i[17], 23); // unchanged
	EXPECT_EQ(i[18], 22); // unchanged
	EXPECT_EQ(i[19], 1073741823);
	EXPECT_EQ(i[20], -1073741823);
	EXPECT_EQ(i[21], -22); // unchanged
	EXPECT_EQ(i[22], -23); // unchanged
	EXPECT_EQ(i[23], -24); // unchanged
}


TEST(SelectiveInputReportParser, ByteAligned_ArrayFields) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0xA1, 0x01,        // Collection (Application)
		0x05, 0x09,        //   Usage Page (Button)
		0x19, 0x01,        //   Usage Minimum (0x01)
		0x29, 0xFE,        //   Usage Maximum (0xFE)
		0x15, 0x01,        //   Logical Minimum (1)
		0x26, 0xFE, 0x00,  //   Logical Maximum (254)
		0x95, 0x06,        //   Report Count (6)
		0x75, 0x08,        //   Report Size (8)
		0x81, 0x40,        //   Input (Data,Array,Abs,No Wrap,Linear,Preferred State,Null State)
		0xC0,              // End Collection
		0xA1, 0x02,        // Collection (Logical)
		0x19, 0x00,        //   Usage Minimum (0x00)
		0x29, 0xFE,        //   Usage Maximum (0xFE)
		0x15, 0x00,        //   Logical Minimum (0)
		0x26, 0xFE, 0x00,  //   Logical Maximum (254)
		0x95, 0x06,        //   Report Count (6)
		0x75, 0x08,        //   Report Size (8)
		0x81, 0x00,        //   Input (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
		0xA1, 0x03,        // Collection (Report)
		0x19, 0x01,        //   Usage Minimum (0x01)
		0x29, 0xFE,        //   Usage Maximum (0xFE)
		0x75, 0x10,        //   Report Size (16)
		0x81, 0x40,        //   Input (Data,Array,Abs,No Wrap,Linear,Preferred State,Null State)
		0xC0,              // End Collection
	};

	struct Config {
		BoolFields b1 {
			.usages { {PAGE_BUTTON, 0, 0xff} },
		};
		BoolFields b2 {
			.usages { {PAGE_BUTTON, 0, 0xff} },
		};
		BoolFields b3 {
			.usages { {PAGE_BUTTON, 0, 0xff} },
		};
		Collection c1 {
			.type = COLLECTION_TYPE_APPLICATION,
			.bools { &b1 },
		};
		Collection c2 {
			.type = COLLECTION_TYPE_LOGICAL,
			.bools { &b2 },
		};
		Collection c3 {
			.type = COLLECTION_TYPE_REPORT,
			.bools { &b3 },
		};
		Collection c {
			.collections { &c1, &c2, &c3 },
		};
	};

	BoolVector b1, b2, b3;
	Config cfg;
	cfg.b1.target = &b1;
	cfg.b2.target = &b2;
	cfg.b3.target = &b3;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_FALSE(cfg.b1.mapped[0]);
	for (size_t i=1; i<0xfe; i++)
		EXPECT_TRUE(cfg.b1.mapped[i]);
	EXPECT_FALSE(cfg.b1.mapped[0xff]);

	for (size_t i=0; i<0xfe; i++)
		EXPECT_TRUE(cfg.b2.mapped[i]);
	EXPECT_FALSE(cfg.b2.mapped[0xff]);

	EXPECT_FALSE(cfg.b3.mapped[0]);
	for (size_t i=1; i<0xfe; i++)
		EXPECT_TRUE(cfg.b3.mapped[i]);
	EXPECT_FALSE(cfg.b3.mapped[0xff]);

	Report r;

	r.UInt8(9);
	r.UInt8(21);
	r.UInt8(8);
	r.UInt8(0);
	r.UInt8(0xfe);
	r.UInt8(0xff); // out of range works the same way as zero: no button pressed

	r.UInt8(2);
	r.UInt8(0);
	r.UInt8(3);
	r.UInt8(1);
	r.UInt8(0xfe);
	r.UInt8(0xff); // out of range works the same way as zero: no button pressed

	// In case of the 16-bit array the logical min is zero while the usage
	// min is 1 so the usage value will be logical value +1 after decoding.
	r.UInt16(0xfd); // translates to usage 0xfe
	r.UInt16(0xffff); // out of range
	r.UInt16(0xff); // out of range
	r.UInt16(5); // translates to usage 6
	r.UInt16(0xfe); // out of range because this translates to usage 0xff due to the +1
	r.UInt16(0); // translates to usage 1

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0xfe; i++)
			if (b1[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 4);
		a.resize(4);
		EXPECT_EQ(a[0], 8);
		EXPECT_EQ(a[1], 9);
		EXPECT_EQ(a[2], 21);
		EXPECT_EQ(a[3], 0xfe);
	}

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0xfe; i++)
			if (b2[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 4);
		a.resize(4);
		EXPECT_EQ(a[0], 1);
		EXPECT_EQ(a[1], 2);
		EXPECT_EQ(a[2], 3);
		EXPECT_EQ(a[3], 0xfe);
	}

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0xfe; i++)
			if (b3[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 3);
		a.resize(3);
		EXPECT_EQ(a[0], 1);
		EXPECT_EQ(a[1], 6);
		EXPECT_EQ(a[2], 0xfe);
	}

	r.Clear();

	r.UInt8(8);
	r.UInt8(0xff); // out of range
	r.UInt8(0);
	r.UInt8(0);
	r.UInt8(0);
	r.UInt8(0);

	r.UInt8(0);
	r.UInt8(0);
	r.UInt8(0);
	r.UInt8(0xff); // out of range
	r.UInt8(0);
	r.UInt8(66);

	r.UInt16(0xfe); // out of range
	r.UInt16(0xfe); // out of range
	r.UInt16(0xfe); // out of range
	r.UInt16(41);   // translates to 42
	r.UInt16(0xfe); // out of range
	r.UInt16(0xfe); // out of range

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0xfe; i++)
			if (b1[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 1);
		a.resize(1);
		EXPECT_EQ(a[0], 8);
	}

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0xfe; i++)
			if (b2[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 1);
		a.resize(1);
		EXPECT_EQ(a[0], 66);
	}

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0xfe; i++)
			if (b3[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 1);
		a.resize(1);
		EXPECT_EQ(a[0], 42);
	}
}


TEST(SelectiveInputReportParser, Not_ByteAligned_ArrayFields) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x05, 0x09,        // Usage Page (Button)
		0x15, 0x00,        // Logical Minimum (0)
		0x95, 0x08,        // Report Count (8)
		0xA1, 0x01,        // Collection (Application)
		0x19, 0x00,        //   Usage Minimum (0x00)
		0x29, 0x7E,        //   Usage Maximum (0x7E)
		0x25, 0x7E,        //   Logical Maximum (0x7E)
		0x75, 0x07,        //   Report Size (7)
		0x81, 0x00,        //   Input (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
		0xA1, 0x02,        // Collection (Logical)
		0x1A, 0x00, 0x50,  //   Usage Minimum (0x5000)  <- the max number of usages per input field is HRP_MAX_REPORT_COUNT
		0x2A, 0xFE, 0x7F,  //   Usage Maximum (0x7FFE)
		0x26, 0xFE, 0x2F,  //   Logical Maximum (0x2FFE)
		0x75, 0x0F,        //   Report Size (15)
		0x81, 0x00,        //   Input (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
		0xA1, 0x03,        // Collection (Report)
		0x1A, 0x00, 0xD0,  //   Usage Minimum (0xD000)  <- the max number of usages per input field is HRP_MAX_REPORT_COUNT
		0x2A, 0xFF, 0xFF,  //   Usage Maximum (0xFFFF)
		0x26, 0xFF, 0x2F,  //   Logical Maximum (0x2FFF)
		0x75, 0x1F,        //   Report Size (31)
		0x81, 0x00,        //   Input (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
	};

	struct Config {
		BoolFields b1 {
			.usages { {PAGE_BUTTON, 0, 0x7f} },
		};
		BoolFields b2 {
			.usages { {PAGE_BUTTON, 0x5000, 0x7fff} },
		};
		BoolFields b3 {
			.usages { {PAGE_BUTTON, 0xd000, 0xffff} },
		};
		Collection c1 {
			.type = COLLECTION_TYPE_APPLICATION,
			.bools { &b1 },
		};
		Collection c2 {
			.type = COLLECTION_TYPE_LOGICAL,
			.bools { &b2 },
		};
		Collection c3 {
			.type = COLLECTION_TYPE_REPORT,
			.bools { &b3 },
		};
		Collection c {
			.collections { &c1, &c2, &c3 },
		};
	};

	BoolVector b1, b2, b3;
	Config cfg;
	cfg.b1.target = &b1;
	cfg.b2.target = &b2;
	cfg.b3.target = &b3;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	for (size_t i = 0; i<0x7e; i++)
		EXPECT_TRUE(cfg.b1.mapped[i]);
	EXPECT_FALSE(cfg.b1.mapped[0x7f]);

	for (size_t i = 0; i<0x2ffe; i++)
		EXPECT_TRUE(cfg.b2.mapped[i]);
	EXPECT_FALSE(cfg.b2.mapped[0x2fff]);

	for (size_t i = 0; i<0x2fff; i++)
		EXPECT_TRUE(cfg.b3.mapped[i]);

	Report r;

	r.Int(0x7f, 7); // out of range
	r.Int(0x7f, 7); // out of range
	r.Int(0x7f, 7); // out of range
	r.Int(42, 7);
	r.Int(0x7f, 7); // out of range
	r.Int(0x7f, 7); // out of range
	r.Int(0x7f, 7); // out of range
	r.Int(0x7f, 7); // out of range

	r.Int(0x7fff, 15); // out of range
	r.Int(0x7fff, 15); // out of range
	r.Int(0x7fff, 15); // out of range
	r.Int(43, 15);
	r.Int(0x7fff, 15); // out of range
	r.Int(0x7fff, 15); // out of range
	r.Int(0x7fff, 15); // out of range
	r.Int(0x7fff, 15); // out of range

	r.Int(0x10000, 31); // out of range
	r.Int(0x10000, 31); // out of range
	r.Int(0x10000, 31); // out of range
	r.Int(44, 31);
	r.Int(0x10000, 31); // out of range
	r.Int(0x10000, 31); // out of range
	r.Int(0x10000, 31); // out of range
	r.Int(0x10000, 31); // out of range

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0x7f; i++)
			if (b1[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 1);
		a.resize(1);
		EXPECT_EQ(a[0], 42);
	}

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0x2fff; i++)
			if (b2[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 1);
		a.resize(1);
		EXPECT_EQ(a[0], 43);
	}

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0x2fff; i++)
			if (b3[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 1);
		a.resize(1);
		EXPECT_EQ(a[0], 44);
	}

	r.Clear();

	r.Int(0, 7);
	r.Int(0x7f, 7); // out of range
	r.Int(0, 7);
	r.Int(0x7e, 7);
	r.Int(0, 7);
	r.Int(1, 7);
	r.Int(0, 7);
	r.Int(0, 7);

	r.Int(0x2fff, 15); // out of range
	r.Int(0x2fff, 15); // out of range
	r.Int(1, 15);
	r.Int(0, 15);
	r.Int(0x2fff, 15); // out of range
	r.Int(0x2ffe, 15);
	r.Int(0x2fff, 15); // out of range
	r.Int(0xffff, 15); // out of range

	r.Int(0x3000, 31); // out of range
	r.Int(0x2fff, 31);
	r.Int(0x3000, 31); // out of range
	r.Int(0x3000, 31); // out of range
	r.Int(0, 31);
	r.Int(0x3000, 31); // out of range
	r.Int(5, 31);
	r.Int(0x3000, 31); // out of range

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0x7f; i++)
			if (b1[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 2);
		a.resize(2);
		EXPECT_EQ(a[0], 1);
		EXPECT_EQ(a[1], 0x7e);
	}

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0x2fff; i++)
			if (b2[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 3);
		a.resize(3);
		EXPECT_EQ(a[0], 0);
		EXPECT_EQ(a[1], 1);
		EXPECT_EQ(a[2], 0x2ffe);
	}

	{
		std::vector<size_t> a;
		for (size_t i = 0; i<=0x2fff; i++)
			if (b3[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 3);
		a.resize(3);
		EXPECT_EQ(a[0], 0);
		EXPECT_EQ(a[1], 5);
		EXPECT_EQ(a[2], 0x2fff);
	}
}


TEST(SelectiveInputReportParser, FieldProperties) {
	MemoryLeakDetector memory_leak_detector;

	static const uint8_t DESC[] = {
		0x95, 0x01,        // Report Count (1)
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x09, 0x30,        // Usage (X)
		0x66, 0x01, 0x10,  // Unit (System: SI Linear, Time: Seconds)
		0x55, 0x0E,        // Unit Exponent (-2)
		0x35, 0x82,        // Physical Minimum (-126)
		0x45, 0x7E,        // Physical Maximum (126)
		0x15, 0x81,        // Logical Minimum (-127)
		0x25, 0x7F,        // Logical Maximum (127)
		0x75, 0x08,        // Report Size (8)
		0x81, 0x42,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,Null State)
		0x09, 0x31,        // Usage (Y)
		0x67, 0x55, 0xAA, 0x55, 0xAA,  // Unit (None)
		0x57, 0xAA, 0x55, 0xAA, 0x55,  // Unit Exponent
		0x36, 0x02, 0x80,  // Physical Minimum (-32766)
		0x46, 0xFE, 0x7F,  // Physical Maximum (32766)
		0x16, 0x01, 0x80,  // Logical Minimum (-32767)
		0x26, 0xFF, 0x7F,  // Logical Maximum (32767)
		0x75, 0x10,        // Report Size (16)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0x09, 0x32,        // Usage (Z)
		0x67, 0xAA, 0x55, 0xAA, 0x55,  // Unit (None)
		0x57, 0x55, 0xAA, 0x55, 0xAA,  // Unit Exponent (undefined)
		0x37, 0x02, 0x00, 0x00, 0x80,  // Physical Minimum (-2147483646)
		0x47, 0xFE, 0xFF, 0xFF, 0x7F,  // Physical Maximum (2147483646)
		0x17, 0x01, 0x00, 0x00, 0x80,  // Logical Minimum (-2147483647)
		0x27, 0xFF, 0xFF, 0xFF, 0x7F,  // Logical Maximum (2147483647)
		0x75, 0x20,        // Report Size (32)
		0x81, 0x06,        // Input (Data,Var,Rel,No Wrap,Linear,Preferred State,No Null Position)
	};

	struct Config {
		Int32Fields f {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Z},
			},
		};
		Collection c {
			.int32s { &f },
		};
	};

	Int32Vector i1;
	Config cfg;
	cfg.f.target = &i1;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.f.mapped[0]);
	EXPECT_TRUE(cfg.f.mapped[1]);
	EXPECT_TRUE(cfg.f.mapped[2]);

	EXPECT_EQ(cfg.f.properties[0].flags, 0x42);
	EXPECT_EQ(cfg.f.properties[0].logical_min, -127);
	EXPECT_EQ(cfg.f.properties[0].logical_max, 127);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[0].physical_min, -126);
	EXPECT_EQ(cfg.f.properties[0].physical_max, 126);
	EXPECT_EQ(cfg.f.properties[0].unit, 0x1001);
	EXPECT_EQ(cfg.f.properties[0].unit_exponent, 0x0e);
#endif

	EXPECT_EQ(cfg.f.properties[1].flags, 0x02);
	EXPECT_EQ(cfg.f.properties[1].logical_min, -32767);
	EXPECT_EQ(cfg.f.properties[1].logical_max, 32767);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[1].physical_min, -32766);
	EXPECT_EQ(cfg.f.properties[1].physical_max, 32766);
	EXPECT_EQ(cfg.f.properties[1].unit, 0xaa55aa55);
	EXPECT_EQ(cfg.f.properties[1].unit_exponent, 0x55aa55aa);
#endif

	EXPECT_EQ(cfg.f.properties[2].flags, 0x06);
	EXPECT_EQ(cfg.f.properties[2].logical_min, -2147483647);
	EXPECT_EQ(cfg.f.properties[2].logical_max, 2147483647);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[2].physical_min, -2147483646);
	EXPECT_EQ(cfg.f.properties[2].physical_max, 2147483646);
	EXPECT_EQ(cfg.f.properties[2].unit, 0x55aa55aa);
	EXPECT_EQ(cfg.f.properties[2].unit_exponent, 0xaa55aa55);
#endif
}


TEST(SelectiveInputReportParser, AutoCorrect_LogicalMax_And_PhysicalMax_Sign) {
	MemoryLeakDetector memory_leak_detector;

	// An 8 bit integer descriptor item parameter can be specified in three
	// different ways: 1-byte, 2-byte or 4-byte item parameter. If the most
	// significant bit of an unsigned 8-bit parameter is set (the value is
	// between 0x80 and 0xff) then it cannot be specified as a 1-byte parameter
	// because sign extension would turn it into a negative 32-bit value.
	// It has to be specified as a 2-byte item parameter (little endian
	// 0x80,0x00 or 0xff,0x00) to prevent sign extension from converting the
	// value to an int32_t by filling the most significant bits with ones.
	// The same applies to 16 bit unsigned values: if the most significant bit
	// is set (the value is between 0x8000 and 0xffff) then it must be
	// specified as a 4-byte parameter to prevent sign extension from doing
	// undesirable things.
	//
	// Unfortunately the previously described behaviour is often overlooked.
	// Specifying unsigned 255 as a 1-byte parameter in LOGICAL_MAX or
	// PHYISCAL_MAX is a common mistake in descriptors. Some HID report parsers
	// (like this one) can spot when the value of LOGICAL_MAX is smaller than
	// LOGICAL_MIN and treat the maximum as an unsigned value (by converting
	// it to int32_t with zero extension instead of sign extension).
	// The same applies to PHYSICAL_MAX and PHYSICAL_MIN. The Linux HID driver
	// performs this correction only if MIN value isn't negative.
	// This library can recognise the mistake with negative MIN values too.
	//
	// This correction is performed by the DescriptorParser but we perform the
	// test through the higher level SelectiveInputReportParser that is built on
	// top of the DescriptorParser to make our job easier.

	static const uint8_t DESC[] = {
		0x95, 0x01,        // Report Count (1)
		0x75, 0x08,        // Report Size (8)
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)

		0x09, 0x30,        // Usage (X)
		0x35, 0x00,        // Physical Minimum (0)      <- non-negative minimum
		0x45, 0x81,        // Physical Maximum (-127)   <- the correct descriptor would be 0x46, 0x81, 0x00,  // Physical Maximum (129)
		0x15, 0x00,        // Logical Minimum (0)       <- non-negative minimum
		0x25, 0x80,        // Logical Maximum (-128)    <- the correct descriptor would be 0x26, 0x80, 0x00,  // Logical Maximum (128)
		0x81, 0x42,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,Null State)

		0x09, 0x30,        // Usage (X)
		0x35, 0xFF,        // Physical Minimum (-1)     <- negative minimum (but it is greater than the negative maximum)
		0x45, 0x81,        // Physical Maximum (-127)   <- the correct descriptor would be 0x46, 0x81, 0x00,  // Physical Maximum (129)
		0x15, 0xFF,        // Logical Minimum (-1)      <- negative minimum (but it is greater than the negative maximum)
		0x25, 0x80,        // Logical Maximum (-128)    <- the correct descriptor would be 0x26, 0x80, 0x00,  // Logical Maximum (128)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)

		0x09, 0x30,        // Usage (X)
		0x35, 0x81,        // Physical Minimum (-127)
		0x45, 0xFF,        // Physical Maximum (-1)     <- negative but still higher than the minimum, no correction needed
		0x15, 0x80,        // Logical Minimum (-128)
		0x25, 0xFF,        // Logical Maximum (-1)      <- negative but still higher than the minimum, no correction needed
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)

		0x75, 0x10,        // Report Size (16)

		0x09, 0x31,        // Usage (Y)
		0x34,              // Physical Minimum (0)      <- non-negative minimum
		0x46, 0x01, 0x80,  // Physical Maximum (-32767) <- the correct descriptor would be 0x47, 0x01, 0x80, 0x00, 0x00
		0x14,              // Logical Minimum (0)       <- non-negative minimum
		0x26, 0x00, 0x80,  // Logical Maximum (-32768)  <- the correct descriptor would be 0x27, 0x00, 0x80, 0x00, 0x00
		0x81, 0x42,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,Null State)

		0x09, 0x31,        // Usage (Y)
		0x35, 0xFF,        // Physical Minimum (-1)     <- negative minimum (but it is greater than the negative maximum)
		0x46, 0x01, 0x80,  // Physical Maximum (-32767) <- the correct descriptor would be 0x47, 0x01, 0x80, 0x00, 0x00
		0x15, 0xFF,        // Logical Minimum (-1)      <- negative minimum (but it is greater than the negative maximum)
		0x26, 0x00, 0x80,  // Logical Maximum (-32768)  <- the correct descriptor would be 0x27, 0x00, 0x80, 0x00, 0x00
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)

		0x09, 0x31,        // Usage (Y)
		0x36, 0x01, 0x80,  // Physical Minimum (-32767)
		0x45, 0xFF,        // Physical Maximum (-1)     <- negative but still higher than the minimum, no correction needed
		0x16, 0x00, 0x80,  // Logical Minimum (-32768)
		0x25, 0xFF,        // Logical Maximum (-1)      <- negative but still higher than the minimum, no correction needed
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
	};

	struct Config {
		Int32Fields f {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
			},
		};
		Collection c {
			.int32s { &f },
		};
	};

	Int32Vector i1;
	Config cfg;
	cfg.f.target = &i1;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.f.mapped[0]);
	EXPECT_TRUE(cfg.f.mapped[1]);
	EXPECT_TRUE(cfg.f.mapped[2]);
	EXPECT_TRUE(cfg.f.mapped[3]);
	EXPECT_TRUE(cfg.f.mapped[4]);
	EXPECT_TRUE(cfg.f.mapped[5]);

	EXPECT_EQ(cfg.f.properties[0].logical_min, 0);
	EXPECT_EQ(cfg.f.properties[0].logical_max, 128); // <- the library converted 0x80 to 0x00000080 instead of 0xffffff80
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[0].physical_min, 0);
	EXPECT_EQ(cfg.f.properties[0].physical_max, 129); // <- the library converted 0x81 to 0x00000081 instead of 0xffffff81
#endif

	EXPECT_EQ(cfg.f.properties[1].logical_min, -1);
	EXPECT_EQ(cfg.f.properties[1].logical_max, 128); // <- the library converted 0x80 to 0x00000080 instead of 0xffffff80
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[1].physical_min, -1);
	EXPECT_EQ(cfg.f.properties[1].physical_max, 129); // <- the library converted 0x81 to 0x00000081 instead of 0xffffff81
#endif

	EXPECT_EQ(cfg.f.properties[2].logical_min, -128);
	EXPECT_EQ(cfg.f.properties[2].logical_max, -1);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[2].physical_min, -127);
	EXPECT_EQ(cfg.f.properties[2].physical_max, -1);
#endif

	EXPECT_EQ(cfg.f.properties[3].logical_min, 0);
	EXPECT_EQ(cfg.f.properties[3].logical_max, 0x8000); // <- the library converted 0x8000 to 0x00008000 instead of 0xffff8000
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[3].physical_min, 0);
	EXPECT_EQ(cfg.f.properties[3].physical_max, 0x8001); // <- the library converted 0x8001 to 0x00008001 instead of 0xffff8001
#endif

	EXPECT_EQ(cfg.f.properties[4].logical_min, -1);
	EXPECT_EQ(cfg.f.properties[4].logical_max, 0x8000); // <- the library converted 0x8000 to 0x00008000 instead of 0xffff8000
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[4].physical_min, -1);
	EXPECT_EQ(cfg.f.properties[4].physical_max, 0x8001); // <- the library converted 0x8001 to 0x00008001 instead of 0xffff8001
#endif

	EXPECT_EQ(cfg.f.properties[5].logical_min, -32768);
	EXPECT_EQ(cfg.f.properties[5].logical_max, -1);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.f.properties[5].physical_min, -32767);
	EXPECT_EQ(cfg.f.properties[5].physical_max, -1);
#endif
}


TEST(SelectiveInputReportParser, IntegerFieldSignedness_ZeroOrSignExtension) {
	MemoryLeakDetector memory_leak_detector;

	// The width of an integer can be anywhere between 1 and 32 bits in the
	// report. The parser zero- or sign-extends it to 32 bits before storing
	// it into an int32_t variable. The integer is signed if it has a negative
	// logical minimum in the descriptor.

	static const uint8_t DESC[] = {
		0x95, 0x01,        // Report Count (1)
		0x75, 0x03,        // Report Size (3)
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)

		// unsigned 3-bit integer
		0x09, 0x30,        // Usage (X)
		0x15, 0x00,        // Logical Minimum (0)
		0x25, 0x07,        // Logical Maximum (7)
		0x81, 0x42,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,Null State)

		// signed 3-bit integer
		0x09, 0x31,        // Usage (Y)
		0x15, 0xFC,        // Logical Minimum (-4)
		0x25, 0x03,        // Logical Maximum (3)
		0x81, 0x02,        // Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
	};

	struct Config {
		Int32Fields f {
			.usages {
				{PAGE_GENERIC_DESKTOP, USAGE_X},
				{PAGE_GENERIC_DESKTOP, USAGE_Y},
			},
		};
		Collection c {
			.int32s { &f },
		};
	};

	Int32Vector i;
	Config cfg;
	cfg.f.target = &i;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg.c, DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.f.mapped[0]);
	EXPECT_TRUE(cfg.f.mapped[1]);

	EXPECT_EQ(cfg.f.properties[0].logical_min, 0);
	EXPECT_EQ(cfg.f.properties[0].logical_max, 7);

	EXPECT_EQ(cfg.f.properties[1].logical_min, -4);
	EXPECT_EQ(cfg.f.properties[1].logical_max, 3);

	Report r;

	r.Int(0b011, 3); // X
	r.Int(0b011, 3); // Y
	r.Int(0, 2);     // padding: 2 bits

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i[0], 3);
	EXPECT_EQ(i[1], 3);

	r.Clear();

	// 4 (0b100) is the most significant bit (the sign bit) of the 3-bit integer
	r.Int(0b100, 3); // X
	r.Int(0b100, 3); // Y
	r.Int(0, 2);     // padding: 2 bits

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i[0], 4);
	EXPECT_EQ(i[1], -4);

	r.Clear();

	r.Int(0b101, 3); // X
	r.Int(0b101, 3); // Y
	r.Int(0, 2);     // padding: 2 bits

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(i[0], 5);
	EXPECT_EQ(i[1], -3);
}




TEST(SelectiveInputReportParser, PermissiveMouseConfig) {
	MemoryLeakDetector memory_leak_detector;

	// This descriptor is a pathological example that declares its axis controls
	// as top level input fields outside of descriptor collections. There are
	// probably no real-wold mice doing this. The Linux HID driver can handle a
	// mouse like this and our builtin MouseConfig will also map it correctly
	// but only with permissive=true passed to its Init method.
	using descriptor_samples::mouse::HANDCRAFTED_4;

	BoolVector buttons;
	Int32Vector axes;
	MouseConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	auto cfg_root = cfg.Init(&buttons, &axes);
	int res = parser.Init(cfg_root, HANDCRAFTED_4, sizeof(HANDCRAFTED_4));
	EXPECT_EQ(res, 0);

	// We should be able to map only the buttons with permissive=false

	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_LEFT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_RIGHT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_MIDDLE]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_BACK]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_FORWARD]);

	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::X]);
	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::Y]);
	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::V_SCROLL]);
	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::H_SCROLL]);

	// We should be able to map the axis controls too permissive=true

	cfg_root = cfg.Init(&buttons, &axes, true);
	res = parser.Init(cfg_root, HANDCRAFTED_4, sizeof(HANDCRAFTED_4));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_LEFT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_RIGHT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_MIDDLE]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_BACK]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_FORWARD]);

	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::X]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::Y]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::V_SCROLL]);
	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::H_SCROLL]);
}


TEST(SelectiveInputReportParser, Overcomplicated_ScienceFictionMouse_WithMultipleReportIDs) {
	MemoryLeakDetector memory_leak_detector;

	// The mouse HID report descriptor below has the following properties:
	// - X and Y axes (8 bits each)
	// - 3 buttons (no padding bits so the report isn't byte-aligned)
	// - Sends the mouse state using three report IDs:
	//   - Report ID (1): XY deltas
	//   - Report ID (2): left and right buttons
	//   - Report ID (3): middle button

	static const uint8_t DESC[] = {
		0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
		0x09, 0x02,        // Usage (Mouse)
		0xA1, 0x01,        // Collection (Application)
		0x09, 0x30,        //   Usage (X)
		0x09, 0x31,        //   Usage (Y)
		0x15, 0x81,        //   Logical Minimum (-127)
		0x25, 0x7F,        //   Logical Maximum (127)
		0x95, 0x02,        //   Report Count (2)
		0x75, 0x08,        //   Report Size (8)
		0x85, 0x01,        //   Report ID (1)
		0x81, 0x06,        //   Input (Data,Var,Rel,No Wrap,Linear,Preferred State,No Null Position)
		0x05, 0x09,        //   Usage Page (Button)
		0x19, 0x01,        //   Usage Minimum (0x01)
		0x29, 0x02,        //   Usage Maximum (0x02)
		0x15, 0x00,        //   Logical Minimum (0)
		0x25, 0x01,        //   Logical Maximum (1)
		0x75, 0x01,        //   Report Size (1)
		0x85, 0x02,        //   Report ID (2)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0x09, 0x03,        //   Usage (0x03)
		0x95, 0x01,        //   Report Count (1)
		0x85, 0x03,        //   Report ID (3)
		0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
		0xC0,              // End Collection
	};

	BoolVector buttons;
	Int32Vector axes;
	MouseConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&buttons, &axes), DESC, sizeof(DESC));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_LEFT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_RIGHT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_MIDDLE]);
	EXPECT_FALSE(cfg.buttons.mapped[MouseConfig::BTN_BACK]);
	EXPECT_FALSE(cfg.buttons.mapped[MouseConfig::BTN_FORWARD]);

	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::X]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::Y]);
	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::V_SCROLL]);
	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::H_SCROLL]);

	EXPECT_EQ(cfg.axes.properties[MouseConfig::X].logical_min, -127);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::X].logical_max, 127);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::Y].logical_min, -127);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::Y].logical_max, 127);

	Report r;

	r.UInt8(1); // Report ID
	r.Int8(2);  // X
	r.Int8(-3); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b000);
	EXPECT_EQ(axes[MouseConfig::X], 2);
	EXPECT_EQ(axes[MouseConfig::Y], -3);

	r.Clear();
	r.UInt8(3); // Report ID
	r.UInt8(1); // button flags: middle button down

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_FALSE(buttons[MouseConfig::BTN_LEFT]);
	EXPECT_FALSE(buttons[MouseConfig::BTN_RIGHT]);
	EXPECT_TRUE(buttons[MouseConfig::BTN_MIDDLE]);
	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b100); // the above 3 checks in compact form on one line

	// This report updated only the state of the middle button and "no change"
	// is indicated by a zero value in case of relative fields like the X and
	// Y deltas of a mouse.
	// Relative fields that aren't updated by a report must be reset to zero
	// by the library because the user has no way of knowing (due to the high
	// level programming interface and the opaque nature of binary report messages)
	// whether or not the value of a specific field is updated by an incoming report.
	EXPECT_EQ(axes[MouseConfig::X], 0);
	EXPECT_EQ(axes[MouseConfig::Y], 0);

	r.Clear();
	r.UInt8(1);   // Report ID
	r.Int8(127);  // X
	r.Int8(-127); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b100);
	EXPECT_EQ(axes[MouseConfig::X], 127);
	EXPECT_EQ(axes[MouseConfig::Y], -127);

	r.Clear();
	r.UInt8(1);   // Report ID
	r.Int8(-62);  // X
	r.Int8(-128); // Y - out of range

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b100);
	EXPECT_EQ(axes[MouseConfig::X], -62);
	// Y had an "out of range" value in the report which means "no change"
	// and that translates to zero value in case of a relative field.
	EXPECT_EQ(axes[MouseConfig::Y], 0);

	r.Clear();
	r.UInt8(2);    // Report ID
	r.UInt8(0b01); // button flags: right button up, left button down

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b101);
	EXPECT_EQ(axes[MouseConfig::X], 0);
	EXPECT_EQ(axes[MouseConfig::Y], 0);

	r.Clear();
	r.UInt8(1);   // Report ID
	r.Int8(-128); // X - out of range
	r.Int8(0x55); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);
	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b101);
	EXPECT_EQ(axes[MouseConfig::X], 0);
	EXPECT_EQ(axes[MouseConfig::Y], 0x55);

	r.Clear();
	r.UInt8(2);    // Report ID
	r.UInt8(0b10); // button flags: right button down, left button up

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b110);
	EXPECT_EQ(axes[MouseConfig::X], 0);
	EXPECT_EQ(axes[MouseConfig::Y], 0);

	r.Clear();
	r.UInt8(3); // Report ID
	r.UInt8(0); // button flags: middle button up

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b010);
	EXPECT_EQ(axes[MouseConfig::X], 0);
	EXPECT_EQ(axes[MouseConfig::Y], 0);
}


TEST(SelectiveInputReportParser, Mouse_Zowie_FK2) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world mouse and trying to map
	// its fields onto the variables of our application using the MouseConfig
	// class provided by the library.

	using descriptor_samples::mouse::ZOWIE_FK2;

	BoolVector buttons;
	Int32Vector axes;
	MouseConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&buttons, &axes), ZOWIE_FK2, sizeof(ZOWIE_FK2));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_LEFT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_RIGHT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_MIDDLE]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_BACK]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_FORWARD]);

	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::X]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::Y]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::V_SCROLL]);
	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::H_SCROLL]);

	EXPECT_EQ(cfg.axes.properties[MouseConfig::X].logical_min, -32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::X].logical_max, 32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::Y].logical_min, -32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::Y].logical_max, 32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::V_SCROLL].logical_min, -127);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::V_SCROLL].logical_max, 127);

	Report r;

	r.UInt8(0b01001); // button flags: left and back buttons down
	r.Int16(0x6666);  // X
	r.Int16(-0x7777); // Y
	r.Int8(6);        // V_SCROLL

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b01001);
	EXPECT_EQ(axes[MouseConfig::X], 0x6666);
	EXPECT_EQ(axes[MouseConfig::Y], -0x7777);
	EXPECT_EQ(axes[MouseConfig::V_SCROLL], 6);

	r.Clear();

	r.UInt8(0b00010); // button flags: right button down
	r.Int16(-32768);  // X - out of range
	r.Int16(-32768);  // Y - out of range
	r.Int8(-128);     // V_SCROLL - out of range

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b00010);
	EXPECT_EQ(axes[MouseConfig::X], 0);
	EXPECT_EQ(axes[MouseConfig::Y], 0);
	EXPECT_EQ(axes[MouseConfig::V_SCROLL], 0);
}


TEST(SelectiveInputReportParser, Mouse_RazerViperUltimate) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world mouse and trying to map
	// its fields onto the variables of our application using the MouseConfig
	// class provided by the library.

	using descriptor_samples::mouse::RAZER_VIPER_ULTIMATE_1;

	BoolVector buttons;
	Int32Vector axes;
	MouseConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&buttons, &axes), RAZER_VIPER_ULTIMATE_1, sizeof(RAZER_VIPER_ULTIMATE_1));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_LEFT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_RIGHT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_MIDDLE]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_BACK]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_FORWARD]);

	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::X]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::Y]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::V_SCROLL]);
	EXPECT_FALSE(cfg.axes.mapped[MouseConfig::H_SCROLL]);

	EXPECT_EQ(cfg.axes.properties[MouseConfig::X].logical_min, -32768);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::X].logical_max, 32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::Y].logical_min, -32768);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::Y].logical_max, 32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::V_SCROLL].logical_min, -127);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::V_SCROLL].logical_max, 127);

	Report r;

	r.UInt8(0b01001); // button flags: left and back buttons down
	r.Int8(0);        // vendor defined
	r.Int8(0);        // vendor defined
	r.Int8(6);        // V_SCROLL
	r.Int16(0x6666);  // X
	r.Int16(-0x7777); // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b01001);
	EXPECT_EQ(axes[MouseConfig::X], 0x6666);
	EXPECT_EQ(axes[MouseConfig::Y], -0x7777);
	EXPECT_EQ(axes[MouseConfig::V_SCROLL], 6);

	r.Clear();

	r.UInt8(0b00010); // button flags: right button down
	r.Int8(0);        // vendor defined
	r.Int8(0);        // vendor defined
	r.Int8(-128);     // V_SCROLL - out of range
	r.Int16(-32768);  // X
	r.Int16(-32768);  // Y

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b00010);
	EXPECT_EQ(axes[MouseConfig::X], -32768);
	EXPECT_EQ(axes[MouseConfig::Y], -32768);
	EXPECT_EQ(axes[MouseConfig::V_SCROLL], 0);
}


TEST(SelectiveInputReportParser, Mouse_Logitech_g305) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world mouse and trying to map
	// its fields onto the variables of our application using the MouseConfig
	// class provided by the library.

	// the descriptor of the g305 declares 16 buttons which is unusual for a mouse
	using descriptor_samples::mouse::LOGITECH_G305_2;

	BoolVector buttons;
	Int32Vector axes;
	MouseConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&buttons, &axes), LOGITECH_G305_2, sizeof(LOGITECH_G305_2));
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_LEFT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_RIGHT]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_MIDDLE]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_BACK]);
	EXPECT_TRUE(cfg.buttons.mapped[MouseConfig::BTN_FORWARD]);

	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::X]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::Y]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::V_SCROLL]);
	EXPECT_TRUE(cfg.axes.mapped[MouseConfig::H_SCROLL]);

	EXPECT_EQ(cfg.axes.properties[MouseConfig::X].logical_min, -32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::X].logical_max, 32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::Y].logical_min, -32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::Y].logical_max, 32767);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::V_SCROLL].logical_min, -127);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::V_SCROLL].logical_max, 127);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::H_SCROLL].logical_min, -127);
	EXPECT_EQ(cfg.axes.properties[MouseConfig::H_SCROLL].logical_max, 127);

	Report r;

	r.UInt8(2);        // Report ID
	r.UInt16(0b01001); // button flags: left and back buttons down
	r.Int16(0x6666);   // X
	r.Int16(-0x7777);  // Y
	r.Int8(6);         // V_SCROLL
	r.Int8(-7);        // H_SCROLL

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b01001);
	EXPECT_EQ(axes[MouseConfig::X], 0x6666);
	EXPECT_EQ(axes[MouseConfig::Y], -0x7777);
	EXPECT_EQ(axes[MouseConfig::V_SCROLL], 6);
	EXPECT_EQ(axes[MouseConfig::H_SCROLL], -7);

	r.Clear();

	r.UInt8(2);        // Report ID
	r.UInt16(0b00010); // button flags: right button down
	r.Int16(-32768);   // X - out of range
	r.Int16(-32768);   // Y - out of range
	r.Int8(-128);      // V_SCROLL - out of range
	r.Int8(-128);      // H_SCROLL - out of range

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint8_t>(0), 0b00010);
	EXPECT_EQ(axes[MouseConfig::X], 0);
	EXPECT_EQ(axes[MouseConfig::Y], 0);
	EXPECT_EQ(axes[MouseConfig::V_SCROLL], 0);
	EXPECT_EQ(axes[MouseConfig::H_SCROLL], 0);
}


TEST(SelectiveInputReportParser, Keyboard_CoolerMaster_MasterKeys_BootProtocol) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world keyboard and trying to map
	// its fields onto the variables of our application using the KeyboardConfig
	// class provided by the library.

	using descriptor_samples::keyboard::COOLERMASTER_MASTERKEYS_S_1;

	BoolVector keys, media_keys;
	MultimediaKeyboardConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&keys, &media_keys), COOLERMASTER_MASTERKEYS_S_1, sizeof(COOLERMASTER_MASTERKEYS_S_1));
	EXPECT_EQ(res, 0);

	for (size_t i=1; i<=0xa4; i++)
		ASSERT_TRUE(cfg.keys.mapped[i]);
	for (size_t i=0xe0; i<=0xe7; i++)
		ASSERT_TRUE(cfg.keys.mapped[i]);

	for (size_t i=0xa5; i<=0xdf; i++)
		ASSERT_FALSE(cfg.keys.mapped[i]);
	for (size_t i=0xe8; i<=0xff; i++)
		ASSERT_FALSE(cfg.keys.mapped[i]);

	for (size_t i=0; i<MediaKeys::NUM_MEDIA_KEYS; i++)
		ASSERT_FALSE(cfg.media_keys.mapped[i]);

	Report r;

	r.UInt8(0b00000011);   // left shift + left ctrl
	r.UInt8(0);            // reserved
	r.UInt8(0);            // array[0]
	r.UInt8((int8_t)165);  // array[1] - out of range
	r.UInt8(USAGE_KEYBOARD_F);      // array[2]
	r.UInt8(USAGE_KEYBOARD_DELETE); // array[3]
	r.UInt8(0);            // array[4]
	r.UInt8((int8_t)0xff); // array[5] - out of range

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
			if (keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 4);
		a.resize(4);
		EXPECT_EQ(a[0], USAGE_KEYBOARD_F);
		EXPECT_EQ(a[1], USAGE_KEYBOARD_DELETE);
		EXPECT_EQ(a[2], USAGE_KEYBOARD_LEFT_CONTROL);
		EXPECT_EQ(a[3], USAGE_KEYBOARD_LEFT_SHIFT);
	}

	r.Clear();

	r.UInt8(0b00000100); // left alt
	r.UInt8(0);          // reserved
	r.UInt8(0);          // array[0]
	r.UInt8(0);          // array[1]
	r.UInt8(0);          // array[2]
	r.UInt8(0);          // array[3]
	r.UInt8(0);          // array[4]
	r.UInt8(0);          // array[5]

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
			if (keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 1);
		a.resize(1);
		EXPECT_EQ(a[0], USAGE_KEYBOARD_LEFT_ALT);
	}
}


TEST(SelectiveInputReportParser, Keyboard_CoolerMaster_MasterKeys_ReportProtocol) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world keyboard and trying to map
	// its fields onto the variables of our application using the KeyboardConfig
	// class provided by the library.

	using descriptor_samples::keyboard::COOLERMASTER_MASTERKEYS_S_3;

	BoolVector keys, media_keys;
	MultimediaKeyboardConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&keys, &media_keys), COOLERMASTER_MASTERKEYS_S_3, sizeof(COOLERMASTER_MASTERKEYS_S_3));
	EXPECT_EQ(res, 0);

	for (size_t i=1; i<=0xe7; i++)
		ASSERT_TRUE(cfg.keys.mapped[i]);

	for (size_t i=0xe8; i<=0xff; i++)
		ASSERT_FALSE(cfg.keys.mapped[i]);

	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_PLAY]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_PAUSE]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_FAST_FORWARD]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_REWIND]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_SCAN_NEXT_TRACK]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_SCAN_PREVIOUS_TRACK]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_STOP]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_EJECT]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_PLAY_PAUSE]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_MUTE]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_VOLUME_INCREMENT]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_VOLUME_DECREMENT]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AC_HOME]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AC_BACK]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AC_FORWARD]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AC_STOP]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AC_REFRESH]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_PREVIOUS_LINK]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_NEXT_LINK]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AC_BOOKMARKS]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_HISTORY]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AL_EMAIL_READER]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AL_CALCULATOR]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AL_LOCAL_MACHINE_BROWSER]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AL_INTERNET_BROWSER]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AL_AUDIO_PLAYER]);

	Report r;

	r.UInt8(2);                     // Report ID
	r.UInt32(0b100000000000010010); // AL bookmarks, play/pause, email reader

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
			if (keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 0);
	}

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MediaKeys::NUM_MEDIA_KEYS; i++)
			if (media_keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 3);
		a.resize(3);
		EXPECT_EQ(a[0], MediaKeys::KEY_PLAY_PAUSE);
		EXPECT_EQ(a[1], MediaKeys::KEY_AC_BOOKMARKS);
		EXPECT_EQ(a[2], MediaKeys::KEY_AL_EMAIL_READER);
	}

	r.Clear();

	r.UInt8(2);  // Report ID
	r.UInt32(0); // all consumer keys are released

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
			if (keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 0);
	}

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MediaKeys::NUM_MEDIA_KEYS; i++)
			if (media_keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 0);
	}

	// Unfortunately we can't test the normal (non-consumer) keys of the keyboard
	// through this descriptor because the developers of the keyboard made a mistake
	// and declared the bitfield as an array input. It should be variable input.
}


TEST(SelectiveInputReportParser, Keyboard_Raspberry_PI_BootProtocol) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world keyboard and trying to map
	// its fields onto the variables of our application using the KeyboardConfig
	// class provided by the library.

	using descriptor_samples::keyboard::RASPBERRY_PI_1;

	BoolVector keys, media_keys;
	MultimediaKeyboardConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&keys, &media_keys), RASPBERRY_PI_1, sizeof(RASPBERRY_PI_1));
	EXPECT_EQ(res, 0);

	for (size_t i=1; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
		ASSERT_TRUE(cfg.keys.mapped[i]);

	for (size_t i=0; i<MediaKeys::NUM_MEDIA_KEYS; i++)
		ASSERT_FALSE(cfg.media_keys.mapped[i]);

	Report r;

	r.UInt8(0b00000011);   // left shift + left ctrl
	r.UInt8(0);            // reserved
	r.UInt8(0);            // array[0]
	r.UInt8(0);            // array[1]
	r.UInt8(USAGE_KEYBOARD_F);      // array[2]
	r.UInt8(USAGE_KEYBOARD_DELETE); // array[3]
	r.UInt8(0);            // array[4]
	r.UInt8(0);            // array[5]

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
			if (keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 4);
		a.resize(4);
		EXPECT_EQ(a[0], USAGE_KEYBOARD_F);
		EXPECT_EQ(a[1], USAGE_KEYBOARD_DELETE);
		EXPECT_EQ(a[2], USAGE_KEYBOARD_LEFT_CONTROL);
		EXPECT_EQ(a[3], USAGE_KEYBOARD_LEFT_SHIFT);
	}

	r.Clear();

	r.UInt8(0b00000100); // left alt
	r.UInt8(0);          // reserved
	r.UInt8(0);          // array[0]
	r.UInt8(0);          // array[1]
	r.UInt8(0);          // array[2]
	r.UInt8(0);          // array[3]
	r.UInt8(0);          // array[4]
	r.UInt8(0);          // array[5]

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
			if (keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 1);
		a.resize(1);
		EXPECT_EQ(a[0], USAGE_KEYBOARD_LEFT_ALT);
	}
}


TEST(SelectiveInputReportParser, Keyboard_Raspberry_PI_ConsumerKeys) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world keyboard and trying to map
	// its fields onto the variables of our application using the KeyboardConfig
	// class provided by the library.

	using descriptor_samples::keyboard::RASPBERRY_PI_2;

	BoolVector keys, media_keys;
	MultimediaKeyboardConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&keys, &media_keys), RASPBERRY_PI_2, sizeof(RASPBERRY_PI_2));
	EXPECT_EQ(res, 0);

	for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
		ASSERT_FALSE(cfg.keys.mapped[i]);

	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_PLAY]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_PAUSE]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_FAST_FORWARD]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_REWIND]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_SCAN_NEXT_TRACK]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_SCAN_PREVIOUS_TRACK]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_STOP]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_EJECT]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_PLAY_PAUSE]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_MUTE]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_VOLUME_INCREMENT]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_VOLUME_DECREMENT]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AC_HOME]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_BACK]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_FORWARD]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_STOP]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_REFRESH]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_PREVIOUS_LINK]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_NEXT_LINK]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_BOOKMARKS]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AC_HISTORY]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AL_EMAIL_READER]);
	EXPECT_TRUE(cfg.media_keys.mapped[MediaKeys::KEY_AL_CALCULATOR]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AL_LOCAL_MACHINE_BROWSER]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AL_INTERNET_BROWSER]);
	EXPECT_FALSE(cfg.media_keys.mapped[MediaKeys::KEY_AL_AUDIO_PLAYER]);

	Report r;

	r.UInt16(0b101000001); // calculator, volume up, play/pause

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
			if (keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 0);
	}

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MediaKeys::NUM_MEDIA_KEYS; i++)
			if (media_keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 3);
		a.resize(3);
		EXPECT_EQ(a[0], MediaKeys::KEY_PLAY_PAUSE);
		EXPECT_EQ(a[1], MediaKeys::KEY_VOLUME_INCREMENT);
		EXPECT_EQ(a[2], MediaKeys::KEY_AL_CALCULATOR);
	}

	r.Clear();

	r.UInt16(0); // all consumer keys are released

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MultimediaKeyboardConfig::NUM_KEYS; i++)
			if (keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 0);
	}

	{
		std::vector<size_t> a;
		for (size_t i=0; i<MediaKeys::NUM_MEDIA_KEYS; i++)
			if (media_keys[i])
				a.push_back(i);
		EXPECT_EQ(a.size(), 0);
	}
}


TEST(SelectiveInputReportParser, Keyboard_MappingOnlyAFewKeys) {
	MemoryLeakDetector memory_leak_detector;

	using descriptor_samples::keyboard::RASPBERRY_PI_1;

	BoolVector keys;
	BoolFields fields {
		.target { &keys },
		.usages {
			// ESDF is a superior alternative to WASD.
			{PAGE_KEYBOARD, USAGE_KEYBOARD_D, USAGE_KEYBOARD_F },
			{PAGE_KEYBOARD, USAGE_KEYBOARD_S },
		},
	};
	Collection cfg_root { .bools{ &fields } };

	// zero-based usage indexes declared in fields.usages:
	static constexpr uint8_t KEY_D = 0;
	static constexpr uint8_t KEY_E = 1;
	static constexpr uint8_t KEY_F = 2;
	static constexpr uint8_t KEY_S = 3;
	static constexpr uint8_t NUM_KEYS = 4;

	SelectiveInputReportParser parser;
	int res = parser.Init(&cfg_root, RASPBERRY_PI_1, sizeof(RASPBERRY_PI_1));
	EXPECT_EQ(res, 0);

	ASSERT_TRUE(fields.mapped[KEY_E]);
	ASSERT_TRUE(fields.mapped[KEY_S]);
	ASSERT_TRUE(fields.mapped[KEY_D]);
	ASSERT_TRUE(fields.mapped[KEY_F]);

	Report r;

	r.UInt8(0b00000011);   // left shift + left ctrl
	r.UInt8(0);            // reserved
	r.UInt8(0);            // array[0]
	r.UInt8(0);            // array[1]
	r.UInt8(USAGE_KEYBOARD_F);      // array[2]
	r.UInt8(USAGE_KEYBOARD_DELETE); // array[3]
	r.UInt8(0);            // array[4]
	r.UInt8(0);            // array[5]

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_FALSE(keys[KEY_E]);
	EXPECT_FALSE(keys[KEY_S]);
	EXPECT_FALSE(keys[KEY_D]);
	EXPECT_TRUE(keys[KEY_F]);

	r.Clear();

	r.UInt8(0b00000100);              // left alt
	r.UInt8(0);                       // reserved
	r.UInt8(USAGE_KEYBOARD_D);        // array[0]
	r.UInt8(0);                       // array[1]
	r.UInt8(USAGE_KEYBOARD_ESCAPE);   // array[2]
	r.UInt8(USAGE_KEYBOARD_E);        // array[3]
	r.UInt8(USAGE_KEYBOARD_ENTER);    // array[4]
	r.UInt8(USAGE_KEYBOARD_SPACEBAR); // array[5]

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_TRUE(keys[KEY_E]);
	EXPECT_FALSE(keys[KEY_S]);
	EXPECT_TRUE(keys[KEY_D]);
	EXPECT_FALSE(keys[KEY_F]);

	r.Clear();

	r.UInt8(0);                // no flags
	r.UInt8(0);                // reserved
	r.UInt8(USAGE_KEYBOARD_S); // array[0]
	r.UInt8(USAGE_KEYBOARD_G); // array[1]
	r.UInt8(USAGE_KEYBOARD_A); // array[2]
	r.UInt8(USAGE_KEYBOARD_W); // array[3]
	r.UInt8(USAGE_KEYBOARD_R); // array[4]
	r.UInt8(USAGE_KEYBOARD_Q); // array[5]

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_FALSE(keys[KEY_E]);
	EXPECT_TRUE(keys[KEY_S]);
	EXPECT_FALSE(keys[KEY_D]);
	EXPECT_FALSE(keys[KEY_F]);
}


TEST(SelectiveInputReportParser, Gamepad_PS4_1) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world keyboard and trying to map
	// its fields onto the variables of our application using the KeyboardConfig
	// class provided by the library.

	using descriptor_samples::gamepad::PS4_1;

	BoolVector buttons;
	Int32Vector axes;
	GamepadConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&buttons, &axes), PS4_1, sizeof(PS4_1));
	EXPECT_EQ(res, 0);

	for (size_t i=0; i<=13; i++)
		EXPECT_TRUE(cfg.buttons.mapped[i]);
	for (size_t i=14; i<=31; i++)
		EXPECT_FALSE(cfg.buttons.mapped[i]);

	EXPECT_EQ(cfg.axes.properties[GamepadConfig::X].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::X].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::Y].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::Y].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::Z].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::Z].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::RX].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::RX].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::RY].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::RY].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::RZ].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::RZ].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::HAT_SWITCH].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[GamepadConfig::HAT_SWITCH].logical_max, 7);

	Report r;

	r.UInt8(1);    // Report ID
	r.UInt8(0);    // X
	r.UInt8(1);    // Y
	r.UInt8(2);    // Z
	r.UInt8(253);  // Rz
	r.UInt(3, 4);  // hat switch
	r.UInt(0b01010101010101, 14); // buttons
	r.UInt(0, 6);  // vendor defined
	r.UInt8(255);  // Rx
	r.UInt8(254);  // Ry
	for (size_t i=0; i<54; i++)
		r.Int8(0); // vendor defined

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint16_t>(0), 0b01010101010101);
	EXPECT_EQ(axes[GamepadConfig::X], 0);
	EXPECT_EQ(axes[GamepadConfig::Y], 1);
	EXPECT_EQ(axes[GamepadConfig::Z], 2);
	EXPECT_EQ(axes[GamepadConfig::RX], 255);
	EXPECT_EQ(axes[GamepadConfig::RY], 254);
	EXPECT_EQ(axes[GamepadConfig::RZ], 253);
	EXPECT_EQ(axes[GamepadConfig::HAT_SWITCH], 3);

	r.Clear();

	r.UInt8(1);    // Report ID
	r.UInt8(4);    // X
	r.UInt8(5);    // Y
	r.UInt8(6);    // Z
	r.UInt8(9);    // Rz
	r.UInt(8, 4);  // hat switch - out of range
	r.UInt(0, 14); // buttons
	r.UInt(0, 6);  // vendor defined
	r.UInt8(7);    // Rx
	r.UInt8(8);    // Ry
	for (size_t i=0; i<54; i++)
		r.Int8(0); // vendor defined

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint16_t>(0), 0);
	EXPECT_EQ(axes[GamepadConfig::X], 4);
	EXPECT_EQ(axes[GamepadConfig::Y], 5);
	EXPECT_EQ(axes[GamepadConfig::Z], 6);
	EXPECT_EQ(axes[GamepadConfig::RX], 7);
	EXPECT_EQ(axes[GamepadConfig::RY], 8);
	EXPECT_EQ(axes[GamepadConfig::RZ], 9);
	EXPECT_EQ(axes[GamepadConfig::HAT_SWITCH], 3);
}


TEST(SelectiveInputReportParser, Gamepad_X52_Pro_HOTAS) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world keyboard and trying to map
	// its fields onto the variables of our application using the KeyboardConfig
	// class provided by the library.

	using descriptor_samples::gamepad::X52_PRO_HOTAS;

	BoolVector buttons;
	Int32Vector axes;
	BigGamepadConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&buttons, &axes), X52_PRO_HOTAS, sizeof(X52_PRO_HOTAS));
	EXPECT_EQ(res, 0);

	for (size_t i=0; i<=38; i++)
		EXPECT_TRUE(cfg.buttons.mapped[i]);
	for (size_t i=39; i<=63; i++)
		EXPECT_FALSE(cfg.buttons.mapped[i]);

	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::X]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::Y]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::Z]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::RX]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::RY]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::RZ]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::SLIDER]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::HAT_SWITCH]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::MOVE_RIGHT_LEFT]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::MOVE_UP_DOWN]);

	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::X].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::X].logical_max, 1023);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Y].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Y].logical_max, 1023);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RX].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RX].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RY].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RY].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RZ].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RZ].logical_max, 1023);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::SLIDER].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::SLIDER].logical_max, 255);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::HAT_SWITCH].logical_min, 1);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::HAT_SWITCH].logical_max, 8);

	Report r;

	r.UInt(1, 10); // X
	r.UInt(2, 10); // Y
	r.UInt(0, 2);  // const padding
	r.UInt(6, 10); // Rz
	r.UInt8(3);    // Z
	r.UInt8(4);    // Rx
	r.UInt8(5);    // Ry
	r.UInt8(7);    // slider
	r.UInt(0b111111000001111100001111000111001101, 39); // buttons
	r.UInt(0, 5);  // const padding
	r.UInt(3, 4);  // hat switch
	r.UInt(8, 4);  // game controls: move right/left
	r.UInt(9, 4);  // game controls: move up/down

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint64_t>(0), 0b111111000001111100001111000111001101);
	EXPECT_EQ(axes[BigGamepadConfig::X], 1);
	EXPECT_EQ(axes[BigGamepadConfig::Y], 2);
	EXPECT_EQ(axes[BigGamepadConfig::Z], 3);
	EXPECT_EQ(axes[BigGamepadConfig::RX], 4);
	EXPECT_EQ(axes[BigGamepadConfig::RY], 5);
	EXPECT_EQ(axes[BigGamepadConfig::RZ], 6);
	EXPECT_EQ(axes[BigGamepadConfig::SLIDER], 7);
	EXPECT_EQ(axes[BigGamepadConfig::MOVE_RIGHT_LEFT], 8);
	EXPECT_EQ(axes[BigGamepadConfig::MOVE_UP_DOWN], 9);
	EXPECT_EQ(axes[BigGamepadConfig::HAT_SWITCH], 3);

	r.Clear();
	r.UInt(21, 10); // X
	r.UInt(22, 10); // Y
	r.UInt(0, 2);   // const padding
	r.UInt(26, 10); // Rz
	r.UInt8(23);    // Z
	r.UInt8(24);    // Rx
	r.UInt8(25);    // Ry
	r.UInt8(27);    // slider
	r.UInt(0, 39);  // buttons
	r.UInt(0, 5);   // const padding
	r.UInt(0, 4);   // hat switch - out of range
	r.UInt(14, 4);  // game controls: move right/left
	r.UInt(15, 4);  // game controls: move up/down

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint64_t>(0), 0);
	EXPECT_EQ(axes[BigGamepadConfig::X], 21);
	EXPECT_EQ(axes[BigGamepadConfig::Y], 22);
	EXPECT_EQ(axes[BigGamepadConfig::Z], 23);
	EXPECT_EQ(axes[BigGamepadConfig::RX], 24);
	EXPECT_EQ(axes[BigGamepadConfig::RY], 25);
	EXPECT_EQ(axes[BigGamepadConfig::RZ], 26);
	EXPECT_EQ(axes[BigGamepadConfig::SLIDER], 27);
	EXPECT_EQ(axes[BigGamepadConfig::MOVE_RIGHT_LEFT], 14);
	EXPECT_EQ(axes[BigGamepadConfig::MOVE_UP_DOWN], 15);
	EXPECT_EQ(axes[BigGamepadConfig::HAT_SWITCH], 3);
}


TEST(SelectiveInputReportParser, Gamepad_Speedlink_PhantomHawk) {
	MemoryLeakDetector memory_leak_detector;

	// Using the HID report descriptor of a real-world keyboard and trying to map
	// its fields onto the variables of our application using the KeyboardConfig
	// class provided by the library.

	// The LOGICAL_MAX and PHYSICAL_MAX values are incorrect (-1 insteaad of 255)
	// but the DescriptorParser can automatically correct them.
	using descriptor_samples::gamepad::SPEEDLINK_PHANTOM_HAWK;

	BoolVector buttons;
	Int32Vector axes;
	BigGamepadConfig cfg;  // builtin mapping config provided by the library

	SelectiveInputReportParser parser;
	int res = parser.Init(cfg.Init(&buttons, &axes), SPEEDLINK_PHANTOM_HAWK, sizeof(SPEEDLINK_PHANTOM_HAWK));
	EXPECT_EQ(res, 0);

	for (size_t i=0; i<=11; i++)
		EXPECT_TRUE(cfg.buttons.mapped[i]);
	for (size_t i=12; i<=63; i++)
		EXPECT_FALSE(cfg.buttons.mapped[i]);

	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::X]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::Y]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::Z]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::Z_2]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::RZ]);
	EXPECT_TRUE(cfg.axes.mapped[BigGamepadConfig::HAT_SWITCH]);

	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::X].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::X].logical_max, 255);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::X].physical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::X].physical_max, 255);
#endif

	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Y].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Y].logical_max, 255);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Y].physical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Y].physical_max, 255);
#endif

	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z].logical_max, 255);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z].physical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z].physical_max, 255);
#endif

	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z_2].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z_2].logical_max, 255);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z_2].physical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::Z_2].physical_max, 255);
#endif

	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RZ].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RZ].logical_max, 255);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RZ].physical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::RZ].physical_max, 255);
#endif

	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::HAT_SWITCH].logical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::HAT_SWITCH].logical_max, 7);
#if HRP_ENABLE_PHYISICAL_UNITS
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::HAT_SWITCH].physical_min, 0);
	EXPECT_EQ(cfg.axes.properties[BigGamepadConfig::HAT_SWITCH].physical_max, 315);
#endif

	Report r;

	r.UInt8(1);    // X
	r.UInt8(2);    // Y
	r.UInt8(3);    // Z
	r.UInt8(4);    // Z_2
	r.UInt8(5);    // Rz
	r.UInt(6, 4);  // hat switch
	r.UInt(0b111001101, 12); // buttons
	r.UInt8(0);    // const padding

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint16_t>(0), 0b111001101);
	EXPECT_EQ(axes[BigGamepadConfig::X], 1);
	EXPECT_EQ(axes[BigGamepadConfig::Y], 2);
	EXPECT_EQ(axes[BigGamepadConfig::Z], 3);
	EXPECT_EQ(axes[BigGamepadConfig::Z_2], 4);
	EXPECT_EQ(axes[BigGamepadConfig::RZ], 5);
	EXPECT_EQ(axes[BigGamepadConfig::HAT_SWITCH], 6);

	r.Clear();

	r.UInt8(11);   // X
	r.UInt8(12);   // Y
	r.UInt8(13);   // Z
	r.UInt8(14);   // Z_2
	r.UInt8(15);   // Rz
	r.UInt(8, 4);  // hat switch - out of range
	r.UInt(0, 12); // buttons
	r.UInt8(0);    // const padding

	res = parser.Parse(r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);

	EXPECT_EQ(buttons.Flags<uint16_t>(0), 0);
	EXPECT_EQ(axes[BigGamepadConfig::X], 11);
	EXPECT_EQ(axes[BigGamepadConfig::Y], 12);
	EXPECT_EQ(axes[BigGamepadConfig::Z], 13);
	EXPECT_EQ(axes[BigGamepadConfig::Z_2], 14);
	EXPECT_EQ(axes[BigGamepadConfig::RZ], 15);
	EXPECT_EQ(axes[BigGamepadConfig::HAT_SWITCH], 6);
}


// This namespace contains a fully functional version of the example code
// listed in the README.md file of this project.
namespace readme_md_example {


struct MountedMouse {
	hid::BitField<hid::MouseConfig::NUM_BUTTONS> buttons;
	hid::Int32Array<hid::MouseConfig::NUM_AXES> axes;
	hid::SelectiveInputReportParser parser;
};

std::map<uint16_t, std::unique_ptr<MountedMouse>> mounted_mice;

uint16_t map_key(uint8_t device_addr, uint8_t hid_interface_number) {
	return ((uint16_t)device_addr << 8) | hid_interface_number;
}

static constexpr int ERR_IGNORED_INTERFACE = 1;

// Returns zero on success.
int on_mount_hid_interface(uint8_t dev_addr, uint8_t hid_interface_num,
		const void* descriptor, size_t size) {
	// This example handles only mice and ignores other device types.
	std::unique_ptr<MountedMouse> p(new MountedMouse);
	auto buttons_ref = p->buttons.Ref();
	auto axes_ref = p->axes.Ref();
	// Using the builtin mouse mapping config. Check out the other builtin
	// mapping configs too: hid::KeyboardConfig, hid::GamepadConfig, etc...
	// You can create and use your own config if you know what you are doing.
	hid::MouseConfig cfg;
	auto cfg_root = cfg.Init(&buttons_ref, &axes_ref);

	// The parser.Init call tries to map the report fields specified in the
	// config onto the `buttons` and `axes` variables of the application.
	int res = p->parser.Init(cfg_root, descriptor, size);
	// Returns hid::ERR_COULD_NOT_MAP_ANY_USAGES if the descriptor doesn't
	// have an application container tagged with Usage(Mouse).
	if (res)
		return res;
	mounted_mice[map_key(dev_addr, hid_interface_num)] = std::move(p);

	// The cfg object is no longer needed after the parser.Init call but
	// it contains potentially useful information in its member variables:

	// Optional: Check which report fields are mapped onto variables.
	printf("V_SCROLL mapped=%d, H_SCROLL mapped=%d\n",
		cfg.axes.mapped[hid::MouseConfig::V_SCROLL] ? 1 : 0,
		cfg.axes.mapped[hid::MouseConfig::H_SCROLL] ? 1 : 0);
	// Optional: Check field properties. Unmapped fields equal to zero/false.
	printf("X min/max: %d/%d\n",
		cfg.axes.properties[hid::MouseConfig::X].logical_min,
		cfg.axes.properties[hid::MouseConfig::X].logical_max);
	return 0;
}

// Returns zero on success.
int on_input_report_received(uint8_t dev_addr, uint8_t hid_interface_num,
		const void* report, size_t size) {
	auto it = mounted_mice.find(map_key(dev_addr, hid_interface_num));
	if (it == mounted_mice.end())
		return ERR_IGNORED_INTERFACE;
	MountedMouse& m = *it->second.get();

	int res = m.parser.Parse(report, size);
	if (res)
		return res == hid::ERR_NOTHING_CHANGED ? 0 : res;

	// TODO: Process the mouse input. Unmapped fields equal to zero/false.
	printf("buttons=%d%d%d%d%d x=%-5d y=%-5d v_scroll=%-5d h_scroll=%-5d\n",
		m.buttons[hid::MouseConfig::BTN_LEFT]    ? 1 : 0,
		m.buttons[hid::MouseConfig::BTN_RIGHT]   ? 1 : 0,
		m.buttons[hid::MouseConfig::BTN_MIDDLE]  ? 1 : 0,
		m.buttons[hid::MouseConfig::BTN_BACK]    ? 1 : 0,
		m.buttons[hid::MouseConfig::BTN_FORWARD] ? 1 : 0,
		m.axes[hid::MouseConfig::X],
		m.axes[hid::MouseConfig::Y],
		m.axes[hid::MouseConfig::V_SCROLL],
		m.axes[hid::MouseConfig::H_SCROLL]);
	return 0;
}

void on_unmount_hid_interface(uint8_t dev_addr, uint8_t hid_interface_num) {
	mounted_mice.erase(map_key(dev_addr, hid_interface_num));
}

TEST(SelectiveInputReportParser, README_md_Example) {
	MemoryLeakDetector memory_leak_detector;

	using descriptor_samples::mouse::ZOWIE_FK2;

	int res = on_mount_hid_interface(0, 0, ZOWIE_FK2, sizeof(ZOWIE_FK2));
	EXPECT_EQ(res, 0);

	Report r;
	r.UInt8(0b01001); // button flags: left and back buttons down
	r.Int16(44);      // X
	r.Int16(-55);     // Y
	r.Int8(6);        // V_SCROLL
	res = on_input_report_received(0, 0, r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);
	EXPECT_EQ(mounted_mice[0]->buttons.Flags<uint8_t>(0), 0b01001);
	EXPECT_EQ(mounted_mice[0]->axes[MouseConfig::X], 44);
	EXPECT_EQ(mounted_mice[0]->axes[MouseConfig::Y], -55);
	EXPECT_EQ(mounted_mice[0]->axes[MouseConfig::V_SCROLL], 6);

	r.Clear();
	r.UInt8(0b00010); // button flags: right button down
	r.Int16(-32768);  // X - out of range
	r.Int16(-32768);  // Y - out of range
	r.Int8(-128);     // V_SCROLL - out of range
	res = on_input_report_received(0, 0, r.Bytes(), r.Size());
	EXPECT_EQ(res, 0);
	EXPECT_EQ(mounted_mice[0]->buttons.Flags<uint8_t>(0), 0b00010);
	EXPECT_EQ(mounted_mice[0]->axes[MouseConfig::X], 0);
	EXPECT_EQ(mounted_mice[0]->axes[MouseConfig::Y], 0);
	EXPECT_EQ(mounted_mice[0]->axes[MouseConfig::V_SCROLL], 0);

	on_unmount_hid_interface(0, 0);
}


} // namespace readme_md_example
